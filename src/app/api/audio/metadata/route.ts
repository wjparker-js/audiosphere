import { NextRequest, NextResponse } from 'next/server';\nimport { audioStreamingService } from '@/services/audio-streaming.service';\nimport { withErrorHandling } from '@/lib/error-handler';\nimport { createApiResponse } from '@/lib/data-transformer';\nimport { withValidation } from '@/lib/validation';\nimport { z } from 'zod';\n\n// Validation schema for metadata request\nconst metadataSchema = z.object({\n  filePath: z.string().min(1, 'File path is required'),\n  includeWaveform: z.boolean().optional().default(false),\n  includeSpectrum: z.boolean().optional().default(false),\n});\n\n/**\n * Get audio file metadata\n * GET /api/audio/metadata?filePath=path/to/file.mp3\n */\nexport const GET = withErrorHandling(async (request: NextRequest) => {\n  const { searchParams } = new URL(request.url);\n  const queryData = Object.fromEntries(searchParams.entries());\n  \n  // Convert string booleans to actual booleans\n  if (queryData.includeWaveform) {\n    queryData.includeWaveform = queryData.includeWaveform === 'true';\n  }\n  if (queryData.includeSpectrum) {\n    queryData.includeSpectrum = queryData.includeSpectrum === 'true';\n  }\n  \n  const validationResult = metadataSchema.safeParse(queryData);\n  \n  if (!validationResult.success) {\n    const errors = validationResult.error.errors.map(err => ({\n      field: err.path.join('.'),\n      message: err.message,\n      code: err.code.toUpperCase()\n    }));\n    \n    return NextResponse.json(\n      createApiResponse(false, null, {\n        code: 'VALIDATION_ERROR',\n        message: 'Invalid request parameters',\n        details: errors\n      }),\n      { status: 422 }\n    );\n  }\n  \n  const { filePath, includeWaveform, includeSpectrum } = validationResult.data;\n  \n  try {\n    // Validate audio file\n    if (!audioStreamingService.isValidAudioFile(filePath)) {\n      return NextResponse.json(\n        createApiResponse(false, null, {\n          code: 'INVALID_AUDIO_FILE',\n          message: 'Invalid audio file format'\n        }),\n        { status: 400 }\n      );\n    }\n    \n    // Get basic metadata\n    const metadata = await audioStreamingService.getAudioMetadata(filePath);\n    \n    if (!metadata) {\n      return NextResponse.json(\n        createApiResponse(false, null, {\n          code: 'FILE_NOT_FOUND',\n          message: 'Audio file not found or cannot be read'\n        }),\n        { status: 404 }\n      );\n    }\n    \n    // Enhanced metadata object\n    const enhancedMetadata = {\n      ...metadata,\n      filePath,\n      estimatedLoadTime: calculateEstimatedLoadTime(metadata.size, metadata.bitrate),\n      qualityInfo: getQualityInfo(metadata.bitrate, metadata.sampleRate),\n      streamingUrls: generateStreamingUrls(filePath),\n    };\n    \n    // Add waveform data if requested (simplified implementation)\n    if (includeWaveform) {\n      enhancedMetadata.waveform = await generateWaveformData(filePath);\n    }\n    \n    // Add spectrum data if requested (simplified implementation)\n    if (includeSpectrum) {\n      enhancedMetadata.spectrum = await generateSpectrumData(filePath);\n    }\n    \n    return NextResponse.json(\n      createApiResponse(true, {\n        metadata: enhancedMetadata,\n        timestamp: new Date().toISOString()\n      })\n    );\n    \n  } catch (error) {\n    console.error('Audio metadata error:', error);\n    \n    return NextResponse.json(\n      createApiResponse(false, null, {\n        code: 'METADATA_ERROR',\n        message: 'Failed to extract audio metadata'\n      }),\n      { status: 500 }\n    );\n  }\n});\n\n/**\n * Upload and process audio file\n * POST /api/audio/metadata\n */\nexport const POST = withErrorHandling(async (request: NextRequest) => {\n  try {\n    const formData = await request.formData();\n    const file = formData.get('file') as File;\n    const generateQualities = formData.get('generateQualities') === 'true';\n    const extractMetadata = formData.get('extractMetadata') !== 'false'; // Default true\n    const normalize = formData.get('normalize') === 'true';\n    \n    if (!file) {\n      return NextResponse.json(\n        createApiResponse(false, null, {\n          code: 'FILE_REQUIRED',\n          message: 'Audio file is required'\n        }),\n        { status: 400 }\n      );\n    }\n    \n    // Validate file size (50MB limit)\n    const maxSize = 50 * 1024 * 1024; // 50MB\n    if (file.size > maxSize) {\n      return NextResponse.json(\n        createApiResponse(false, null, {\n          code: 'FILE_TOO_LARGE',\n          message: `File size exceeds ${maxSize / (1024 * 1024)}MB limit`\n        }),\n        { status: 413 }\n      );\n    }\n    \n    // Process the upload\n    const result = await audioStreamingService.processAudioUpload(file, {\n      generateQualities,\n      extractMetadata,\n      normalize,\n    });\n    \n    if (!result.success) {\n      return NextResponse.json(\n        createApiResponse(false, null, {\n          code: 'UPLOAD_FAILED',\n          message: result.error || 'Failed to process audio file'\n        }),\n        { status: 400 }\n      );\n    }\n    \n    return NextResponse.json(\n      createApiResponse(true, {\n        upload: result,\n        message: 'Audio file processed successfully'\n      }),\n      { status: 201 }\n    );\n    \n  } catch (error) {\n    console.error('Audio upload error:', error);\n    \n    return NextResponse.json(\n      createApiResponse(false, null, {\n        code: 'UPLOAD_ERROR',\n        message: 'Failed to upload and process audio file'\n      }),\n      { status: 500 }\n    );\n  }\n});\n\n/**\n * Helper functions\n */\n\nfunction calculateEstimatedLoadTime(fileSize: number, bitrate: number): {\n  fast: number; // 4G connection\n  medium: number; // 3G connection\n  slow: number; // 2G connection\n} {\n  // Estimate load times based on typical connection speeds\n  const fileSizeMB = fileSize / (1024 * 1024);\n  \n  return {\n    fast: Math.ceil(fileSizeMB / 10), // 10 Mbps\n    medium: Math.ceil(fileSizeMB / 3), // 3 Mbps\n    slow: Math.ceil(fileSizeMB / 0.5), // 0.5 Mbps\n  };\n}\n\nfunction getQualityInfo(bitrate: number, sampleRate: number): {\n  level: 'low' | 'medium' | 'high' | 'lossless';\n  description: string;\n  recommendation: string;\n} {\n  if (bitrate >= 1000) {\n    return {\n      level: 'lossless',\n      description: 'Lossless quality audio',\n      recommendation: 'Best for audiophiles and high-end equipment'\n    };\n  } else if (bitrate >= 256) {\n    return {\n      level: 'high',\n      description: 'High quality audio',\n      recommendation: 'Excellent for most listening scenarios'\n    };\n  } else if (bitrate >= 192) {\n    return {\n      level: 'medium',\n      description: 'Good quality audio',\n      recommendation: 'Good balance of quality and file size'\n    };\n  } else {\n    return {\n      level: 'low',\n      description: 'Basic quality audio',\n      recommendation: 'Suitable for voice content or limited bandwidth'\n    };\n  }\n}\n\nfunction generateStreamingUrls(filePath: string): {\n  low: string;\n  medium: string;\n  high: string;\n  lossless?: string;\n} {\n  const baseUrl = '/api/audio/stream';\n  \n  return {\n    low: `${baseUrl}/${filePath}?quality=low`,\n    medium: `${baseUrl}/${filePath}?quality=medium`,\n    high: `${baseUrl}/${filePath}?quality=high`,\n    lossless: `${baseUrl}/${filePath}?quality=lossless`,\n  };\n}\n\n// Simplified waveform generation (in a real implementation, you'd use audio analysis libraries)\nasync function generateWaveformData(filePath: string): Promise<number[]> {\n  // This would typically use libraries like Web Audio API or server-side audio processing\n  // For now, return mock data\n  const mockWaveform = Array.from({ length: 100 }, (_, i) => {\n    return Math.sin(i * 0.1) * Math.random() * 0.8 + 0.1;\n  });\n  \n  return mockWaveform;\n}\n\n// Simplified spectrum generation\nasync function generateSpectrumData(filePath: string): Promise<{\n  frequencies: number[];\n  magnitudes: number[];\n}> {\n  // This would typically use FFT analysis\n  // For now, return mock data\n  const frequencies = Array.from({ length: 50 }, (_, i) => i * 100); // 0-5000 Hz\n  const magnitudes = Array.from({ length: 50 }, () => Math.random());\n  \n  return { frequencies, magnitudes };\n}\n"}