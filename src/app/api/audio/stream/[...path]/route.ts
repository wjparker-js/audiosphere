import { NextRequest, NextResponse } from 'next/server';\nimport { audioStreamingService } from '@/services/audio-streaming.service';\nimport { withErrorHandling } from '@/lib/error-handler';\nimport { createApiResponse } from '@/lib/data-transformer';\n\n/**\n * Audio streaming endpoint with range request support\n * Handles: /api/audio/stream/[...path]\n */\nexport const GET = withErrorHandling(async (\n  request: NextRequest,\n  { params }: { params: { path: string[] } }\n) => {\n  try {\n    // Reconstruct file path from segments\n    const filePath = params.path.join('/');\n    \n    if (!filePath) {\n      return NextResponse.json(\n        createApiResponse(false, null, {\n          code: 'INVALID_PATH',\n          message: 'Audio file path is required'\n        }),\n        { status: 400 }\n      );\n    }\n\n    // Validate file extension\n    if (!audioStreamingService.isValidAudioFile(filePath)) {\n      return NextResponse.json(\n        createApiResponse(false, null, {\n          code: 'INVALID_AUDIO_FILE',\n          message: 'Invalid audio file format'\n        }),\n        { status: 400 }\n      );\n    }\n\n    // Get streaming options from query parameters\n    const { searchParams } = new URL(request.url);\n    const quality = searchParams.get('quality') as 'low' | 'medium' | 'high' | 'lossless' || 'medium';\n    const format = searchParams.get('format') as 'mp3' | 'aac' | 'ogg' | 'webm' || 'mp3';\n    const enableCache = searchParams.get('cache') !== 'false';\n    \n    // Get client information for quality adaptation\n    const userAgent = request.headers.get('user-agent') || '';\n    const connectionType = request.headers.get('connection-type');\n    const bandwidth = request.headers.get('bandwidth') ? parseFloat(request.headers.get('bandwidth')!) : undefined;\n    \n    // Determine optimal quality if not specified\n    const optimalQuality = quality === 'auto' \n      ? audioStreamingService.getOptimalQuality(userAgent, connectionType || undefined, bandwidth)\n      : quality;\n\n    // Stream the audio file\n    const streamResponse = await audioStreamingService.streamAudio(request, filePath, {\n      quality: optimalQuality,\n      format,\n      enableRangeRequests: true,\n      enableCaching: enableCache,\n    });\n\n    // Add additional headers for better streaming experience\n    streamResponse.headers.set('X-Content-Type-Options', 'nosniff');\n    streamResponse.headers.set('X-Frame-Options', 'DENY');\n    \n    // Add CORS headers if needed\n    const origin = request.headers.get('origin');\n    if (origin && process.env.ALLOWED_ORIGINS?.includes(origin)) {\n      streamResponse.headers.set('Access-Control-Allow-Origin', origin);\n      streamResponse.headers.set('Access-Control-Allow-Methods', 'GET, HEAD, OPTIONS');\n      streamResponse.headers.set('Access-Control-Allow-Headers', 'Range, If-Range, Cache-Control');\n    }\n\n    return streamResponse;\n  } catch (error) {\n    console.error('Audio streaming error:', error);\n    \n    return NextResponse.json(\n      createApiResponse(false, null, {\n        code: 'STREAMING_ERROR',\n        message: 'Failed to stream audio file'\n      }),\n      { status: 500 }\n    );\n  }\n});\n\n/**\n * Handle HEAD requests for audio metadata\n */\nexport const HEAD = withErrorHandling(async (\n  request: NextRequest,\n  { params }: { params: { path: string[] } }\n) => {\n  try {\n    const filePath = params.path.join('/');\n    \n    if (!filePath || !audioStreamingService.isValidAudioFile(filePath)) {\n      return new NextResponse(null, { status: 404 });\n    }\n\n    // Get audio metadata\n    const metadata = await audioStreamingService.getAudioMetadata(filePath);\n    \n    if (!metadata) {\n      return new NextResponse(null, { status: 404 });\n    }\n\n    // Return headers with metadata\n    const headers = new Headers({\n      'Content-Length': metadata.size.toString(),\n      'Content-Type': `audio/${metadata.format}`,\n      'Accept-Ranges': 'bytes',\n      'X-Audio-Duration': metadata.duration.toString(),\n      'X-Audio-Bitrate': metadata.bitrate.toString(),\n      'X-Audio-Sample-Rate': metadata.sampleRate.toString(),\n      'X-Audio-Channels': metadata.channels.toString(),\n      'Cache-Control': 'public, max-age=3600',\n    });\n\n    return new NextResponse(null, {\n      status: 200,\n      headers,\n    });\n  } catch (error) {\n    console.error('Audio metadata error:', error);\n    return new NextResponse(null, { status: 500 });\n  }\n});\n\n/**\n * Handle OPTIONS requests for CORS preflight\n */\nexport const OPTIONS = async (request: NextRequest) => {\n  const origin = request.headers.get('origin');\n  \n  const headers = new Headers({\n    'Access-Control-Allow-Methods': 'GET, HEAD, OPTIONS',\n    'Access-Control-Allow-Headers': 'Range, If-Range, Cache-Control, Authorization',\n    'Access-Control-Max-Age': '86400', // 24 hours\n  });\n  \n  if (origin && process.env.ALLOWED_ORIGINS?.includes(origin)) {\n    headers.set('Access-Control-Allow-Origin', origin);\n  }\n  \n  return new NextResponse(null, {\n    status: 200,\n    headers,\n  });\n};\n"}