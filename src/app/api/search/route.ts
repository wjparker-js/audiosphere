import { NextRequest, NextResponse } from 'next/server';\nimport pool from '@/lib/database';\nimport { DataTransformer, createApiResponse } from '@/lib/data-transformer';\nimport { ErrorHandler, withErrorHandling } from '@/lib/error-handler';\nimport { searchSchemas } from '@/lib/validation';\nimport { withSearchRateLimit } from '@/lib/middleware/rateLimitMiddleware';\n\n// GET endpoint for unified search across all content types with rate limiting\nexport const GET = withSearchRateLimit(\n  withErrorHandling(async (request: NextRequest) => {\n    const { searchParams } = new URL(request.url);\n    \n    // Parse and validate query parameters using Zod schema\n    const queryData = Object.fromEntries(searchParams.entries());\n    const validationResult = searchSchemas.query.safeParse(queryData);\n\n    if (!validationResult.success) {\n      const validationErrors = validationResult.error.errors.map(err => ({\n        field: err.path.join('.'),\n        message: err.message,\n        code: err.code.toUpperCase()\n      }));\n      \n      return ErrorHandler.handleValidationError({\n        name: 'ValidationError',\n        message: 'Invalid search parameters',\n        details: validationErrors\n      } as any);\n    }\n\n    const { q: query, types: typesString, limit, userId } = validationResult.data;\n    const types = typesString.split(',');\n    const searchTerm = `%${query.trim()}%`;\n    \n    const results: any = {\n      albums: [],\n      tracks: [],\n      playlists: [],\n      blogs: [],\n      stats: {\n        totalResults: 0,\n        albumResults: 0,\n        trackResults: 0,\n        playlistResults: 0,\n        blogResults: 0\n      }\n    };\n\n    // Execute searches in parallel based on requested types\n    const searchPromises: Promise<any>[] = [];\n\n    // Albums search\n    if (types.includes('albums')) {\n      searchPromises.push(\n        pool.execute(`\n          SELECT \n            a.id,\n            a.title,\n            a.artist,\n            a.description,\n            a.cover_image_url,\n            a.genre_id,\n            a.track_count,\n            a.status,\n            a.created_by,\n            a.created_at,\n            a.updated_at,\n            g.name as genre_name,\n            u.username as created_by_username,\n            'album' as result_type\n          FROM albums a \n          LEFT JOIN genres g ON a.genre_id = g.id \n          LEFT JOIN users u ON a.created_by = u.id\n          WHERE a.status = 'published' \n            AND (a.title LIKE ? OR a.artist LIKE ? OR a.description LIKE ?)\n          ORDER BY a.created_at DESC\n          LIMIT ?\n        `, [searchTerm, searchTerm, searchTerm, limit])\n          .then(([rows]) => ({ type: 'albums', data: rows }))\n      );\n    }\n\n    // Tracks search\n    if (types.includes('tracks')) {\n      searchPromises.push(\n        pool.execute(`\n          SELECT \n            id,\n            title,\n            artist,\n            album_title,\n            track_number,\n            duration,\n            duration_seconds,\n            file_path,\n            play_count,\n            status,\n            created_at,\n            updated_at,\n            'track' as result_type\n          FROM tracks \n          WHERE status = 'published' \n            AND (title LIKE ? OR artist LIKE ? OR album_title LIKE ?)\n          ORDER BY play_count DESC, created_at DESC\n          LIMIT ?\n        `, [searchTerm, searchTerm, searchTerm, limit])\n          .then(([rows]) => ({ type: 'tracks', data: rows }))\n      );\n    }\n\n    // Playlists search\n    if (types.includes('playlists')) {\n      searchPromises.push(\n        pool.execute(`\n          SELECT \n            p.id,\n            p.name,\n            p.description,\n            p.is_public,\n            p.user_id,\n            p.created_at,\n            p.updated_at,\n            u.username as owner_name,\n            COUNT(pt.track_id) as track_count,\n            'playlist' as result_type\n          FROM playlists p\n          LEFT JOIN users u ON p.user_id = u.id\n          LEFT JOIN playlist_tracks pt ON p.id = pt.playlist_id\n          WHERE (p.name LIKE ? OR p.description LIKE ?)\n            AND (p.is_public = 1 OR p.user_id = ?)\n          GROUP BY p.id, p.name, p.description, p.is_public, p.user_id, p.created_at, p.updated_at, u.username\n          ORDER BY p.created_at DESC\n          LIMIT ?\n        `, [searchTerm, searchTerm, userId, limit])\n          .then(([rows]) => ({ type: 'playlists', data: rows }))\n      );\n    }\n\n    // Blog posts search\n    if (types.includes('blogs')) {\n      searchPromises.push(\n        pool.execute(`\n          SELECT \n            bp.id,\n            bp.title,\n            bp.slug,\n            bp.excerpt,\n            bp.content,\n            bp.featured_image_url,\n            bp.status,\n            bp.published_at,\n            bp.view_count,\n            bp.created_at,\n            bp.updated_at,\n            bp.user_id,\n            u.username as author_name,\n            COALESCE(c.comment_count, 0) as comment_count,\n            'blog' as result_type\n          FROM blog_posts bp\n          LEFT JOIN users u ON bp.user_id = u.id\n          LEFT JOIN (\n            SELECT blog_post_id, COUNT(*) as comment_count\n            FROM comments\n            WHERE status = 'approved'\n            GROUP BY blog_post_id\n          ) c ON bp.id = c.blog_post_id\n          WHERE bp.status = 'published'\n            AND (bp.title LIKE ? OR bp.content LIKE ? OR bp.excerpt LIKE ?)\n          ORDER BY bp.published_at DESC\n          LIMIT ?\n        `, [searchTerm, searchTerm, searchTerm, limit])\n          .then(([rows]) => ({ type: 'blogs', data: rows }))\n      );\n    }\n\n    // Execute all searches in parallel\n    const searchResults = await Promise.all(searchPromises);\n\n    // Process and transform results\n    searchResults.forEach(({ type, data }) => {\n      switch (type) {\n        case 'albums':\n          results.albums = (data as any[]).map(album => \n            DataTransformer.sanitizeAlbum({\n              ...album,\n              genre_name: album.genre_name\n            })\n          );\n          results.stats.albumResults = results.albums.length;\n          break;\n\n        case 'tracks':\n          results.tracks = (data as any[]).map(track => \n            DataTransformer.sanitizeTrack(track)\n          );\n          results.stats.trackResults = results.tracks.length;\n          break;\n\n        case 'playlists':\n          results.playlists = (data as any[]).map((playlist: any) => ({\n            id: DataTransformer.toInt(playlist.id),\n            name: DataTransformer.toString(playlist.name),\n            description: playlist.description || null,\n            isPublic: Boolean(playlist.is_public),\n            userId: DataTransformer.toInt(playlist.user_id),\n            trackCount: DataTransformer.toInt(playlist.track_count),\n            ownerName: DataTransformer.toString(playlist.owner_name, 'Unknown User'),\n            createdAt: DataTransformer.parseDate(playlist.created_at) || new Date().toISOString(),\n            updatedAt: DataTransformer.parseDate(playlist.updated_at) || new Date().toISOString()\n          }));\n          results.stats.playlistResults = results.playlists.length;\n          break;\n\n        case 'blogs':\n          results.blogs = (data as any[]).map(post => \n            DataTransformer.sanitizeBlogPost(post)\n          );\n          results.stats.blogResults = results.blogs.length;\n          break;\n      }\n    });\n\n    // Calculate total results\n    results.stats.totalResults = \n      results.stats.albumResults + \n      results.stats.trackResults + \n      results.stats.playlistResults + \n      results.stats.blogResults;\n\n    return NextResponse.json(\n      createApiResponse(true, {\n        ...results,\n        query: query.trim(),\n        searchTypes: types,\n        meta: {\n          timestamp: new Date().toISOString(),\n          searchTerm: query.trim(),\n          limit,\n          userId\n        }\n      })\n    );\n  })\n);\n"}