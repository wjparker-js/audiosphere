import { NextRequest, NextResponse } from 'next/server';\nimport pool from '@/lib/database';\nimport { DataTransformer, createApiResponse } from '@/lib/data-transformer';\nimport { ErrorHandler, withErrorHandling } from '@/lib/error-handler';\nimport { dashboardSchemas } from '@/lib/validation';\n\n// GET endpoint to fetch all dashboard data in a single request\nexport const GET = withErrorHandling(async (request: NextRequest) => {\n  const { searchParams } = new URL(request.url);\n  \n  // Parse and validate query parameters using Zod schema\n  const queryData = Object.fromEntries(searchParams.entries());\n  const validationResult = dashboardSchemas.query.safeParse(queryData);\n\n  if (!validationResult.success) {\n    const validationErrors = validationResult.error.errors.map(err => ({\n      field: err.path.join('.'),\n      message: err.message,\n      code: err.code.toUpperCase()\n    }));\n    \n    return ErrorHandler.handleValidationError({\n      name: 'ValidationError',\n      message: 'Invalid dashboard query parameters',\n      details: validationErrors\n    } as any);\n  }\n\n  const { albumLimit, playlistLimit, trackLimit, blogLimit, userId } = validationResult.data;\n\n  // Execute all queries in parallel for better performance\n  const [albumsResult, playlistsResult, tracksResult, blogPostsResult] = await Promise.all([\n    // Albums query\n    pool.execute(`\n      SELECT \n        a.id,\n        a.title,\n        a.artist,\n        a.description,\n        a.cover_image_url,\n        a.genre_id,\n        a.track_count,\n        a.status,\n        a.created_by,\n        a.created_at,\n        a.updated_at,\n        g.name as genre_name,\n        u.username as created_by_username\n      FROM albums a \n      LEFT JOIN genres g ON a.genre_id = g.id \n      LEFT JOIN users u ON a.created_by = u.id\n      WHERE a.status = 'published'\n      ORDER BY a.created_at DESC \n      LIMIT ?\n    `, [albumLimit]),\n\n    // Playlists query\n    pool.execute(`\n      SELECT \n        p.id,\n        p.name,\n        p.description,\n        p.is_public,\n        p.user_id,\n        p.created_at,\n        p.updated_at,\n        u.username as owner_name,\n        COUNT(pt.track_id) as track_count\n      FROM playlists p\n      LEFT JOIN users u ON p.user_id = u.id\n      LEFT JOIN playlist_tracks pt ON p.id = pt.playlist_id\n      WHERE p.user_id = ?\n      GROUP BY p.id, p.name, p.description, p.is_public, p.user_id, p.created_at, p.updated_at, u.username\n      ORDER BY p.created_at DESC\n      LIMIT ?\n    `, [userId, playlistLimit]),\n\n    // Tracks query (popular tracks)\n    pool.execute(`\n      SELECT \n        id,\n        title,\n        artist,\n        album_title,\n        track_number,\n        duration,\n        duration_seconds,\n        file_path,\n        play_count,\n        status,\n        created_at,\n        updated_at\n      FROM tracks \n      WHERE status = 'published'\n      ORDER BY play_count DESC, track_number ASC\n      LIMIT ?\n    `, [trackLimit]),\n\n    // Blog posts query\n    pool.execute(`\n      SELECT \n        bp.id,\n        bp.title,\n        bp.slug,\n        bp.excerpt,\n        bp.content,\n        bp.featured_image_url,\n        bp.status,\n        bp.published_at,\n        bp.view_count,\n        bp.created_at,\n        bp.updated_at,\n        bp.user_id,\n        u.username as author_name,\n        COALESCE(c.comment_count, 0) as comment_count\n      FROM blog_posts bp\n      LEFT JOIN users u ON bp.user_id = u.id\n      LEFT JOIN (\n        SELECT blog_post_id, COUNT(*) as comment_count\n        FROM comments\n        WHERE status = 'approved'\n        GROUP BY blog_post_id\n      ) c ON bp.id = c.blog_post_id\n      WHERE bp.status = 'published'\n      ORDER BY bp.published_at DESC\n      LIMIT ?\n    `, [blogLimit])\n  ]);\n\n  // Transform and sanitize all data\n  const albums = (albumsResult[0] as any[]).map(album => \n    DataTransformer.sanitizeAlbum({\n      ...album,\n      genre_name: album.genre_name\n    })\n  );\n\n  const playlists = (playlistsResult[0] as any[]).map(playlist => ({\n    id: DataTransformer.toInt(playlist.id),\n    name: DataTransformer.toString(playlist.name),\n    description: playlist.description || null,\n    isPublic: Boolean(playlist.is_public),\n    userId: DataTransformer.toInt(playlist.user_id),\n    trackCount: DataTransformer.toInt(playlist.track_count),\n    ownerName: DataTransformer.toString(playlist.owner_name, 'Unknown User'),\n    createdAt: DataTransformer.parseDate(playlist.created_at) || new Date().toISOString(),\n    updatedAt: DataTransformer.parseDate(playlist.updated_at) || new Date().toISOString()\n  }));\n\n  const tracks = (tracksResult[0] as any[]).map(track => \n    DataTransformer.sanitizeTrack(track)\n  );\n\n  const blogPosts = (blogPostsResult[0] as any[]).map(post => \n    DataTransformer.sanitizeBlogPost(post)\n  );\n\n  // Calculate summary statistics\n  const stats = {\n    totalAlbums: albums.length,\n    totalPlaylists: playlists.length,\n    totalTracks: tracks.length,\n    totalBlogPosts: blogPosts.length,\n    totalItems: albums.length + playlists.length + blogPosts.length\n  };\n\n  // Return consolidated dashboard data\n  return NextResponse.json(\n    createApiResponse(true, {\n      albums,\n      playlists,\n      tracks,\n      blogPosts,\n      stats,\n      meta: {\n        timestamp: new Date().toISOString(),\n        limits: {\n          albums: albumLimit,\n          playlists: playlistLimit,\n          tracks: trackLimit,\n          blogPosts: blogLimit\n        }\n      }\n    })\n  );\n});\n"