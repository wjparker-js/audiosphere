'use client';
import { useEffect } from "react";


import { useState } from "react";


import { useMemo } from "react";


import { useMemo } from "react";


import { useMemo } from "react";


import { useQuery } from "@tanstack/react-query";

\n\nimport { useQuery } from '@tanstack/react-query';\nimport { useMemo, useState, useEffect } from 'react';\n\n// Types for search results\ninterface SearchStats {\n  totalResults: number;\n  albumResults: number;\n  trackResults: number;\n  playlistResults: number;\n  blogResults: number;\n}\n\ninterface SearchResults {\n  albums: any[];\n  tracks: any[];\n  playlists: any[];\n  blogs: any[];\n  stats: SearchStats;\n  query: string;\n  searchTypes: string[];\n  meta: {\n    timestamp: string;\n    searchTerm: string;\n    limit: number;\n    userId: string;\n  };\n}\n\n// Options for search query\ninterface SearchOptions {\n  query: string;\n  types?: string[];\n  limit?: number;\n  userId?: string;\n  enabled?: boolean;\n}\n\n// Fetch search results\nasync function fetchSearchResults(options: SearchOptions): Promise<SearchResults> {\n  const {\n    query,\n    types = ['albums', 'tracks', 'playlists', 'blogs'],\n    limit = 20,\n    userId = '1'\n  } = options;\n\n  const params = new URLSearchParams({\n    q: query,\n    types: types.join(','),\n    limit: limit.toString(),\n    userId\n  });\n\n  const response = await fetch(`/api/search?${params}`);\n  if (!response.ok) {\n    throw new Error('Failed to fetch search results');\n  }\n  \n  const result = await response.json();\n  return result.data;\n}\n\n// Hook for unified search across all content types\nexport function useSearch(options: SearchOptions) {\n  const {\n    query,\n    types = ['albums', 'tracks', 'playlists', 'blogs'],\n    limit = 20,\n    userId = '1',\n    enabled = true\n  } = options;\n\n  // Only enable search if query has at least 2 characters\n  const shouldSearch = enabled && query.trim().length >= 2;\n\n  return useQuery({\n    queryKey: ['search', { query: query.trim(), types, limit, userId }],\n    queryFn: () => fetchSearchResults(options),\n    enabled: shouldSearch,\n    staleTime: 2 * 60 * 1000, // 2 minutes\n    gcTime: 5 * 60 * 1000, // 5 minutes\n  });\n}\n\n// Hook for searching specific content types\nexport function useSearchAlbums(query: string, limit = 20) {\n  const { data, ...rest } = useSearch({ \n    query, \n    types: ['albums'], \n    limit \n  });\n  \n  return {\n    data: data?.albums || [],\n    stats: data?.stats,\n    ...rest\n  };\n}\n\nexport function useSearchTracks(query: string, limit = 20) {\n  const { data, ...rest } = useSearch({ \n    query, \n    types: ['tracks'], \n    limit \n  });\n  \n  return {\n    data: data?.tracks || [],\n    stats: data?.stats,\n    ...rest\n  };\n}\n\nexport function useSearchPlaylists(query: string, limit = 20, userId = '1') {\n  const { data, ...rest } = useSearch({ \n    query, \n    types: ['playlists'], \n    limit, \n    userId \n  });\n  \n  return {\n    data: data?.playlists || [],\n    stats: data?.stats,\n    ...rest\n  };\n}\n\nexport function useSearchBlogs(query: string, limit = 20) {\n  const { data, ...rest } = useSearch({ \n    query, \n    types: ['blogs'], \n    limit \n  });\n  \n  return {\n    data: data?.blogs || [],\n    stats: data?.stats,\n    ...rest\n  };\n}\n\n// Hook for search suggestions/autocomplete\nexport function useSearchSuggestions(query: string) {\n  const { data, isLoading } = useSearch({ \n    query, \n    limit: 5, // Smaller limit for suggestions\n    enabled: query.trim().length >= 1 // Enable with just 1 character\n  });\n\n  const suggestions = useMemo(() => {\n    if (!data) return [];\n    \n    const allSuggestions = [\n      ...data.albums.map((album: any) => ({ \n        type: 'album', \n        title: album.title, \n        subtitle: album.artist,\n        id: album.id \n      })),\n      ...data.tracks.map((track: any) => ({ \n        type: 'track', \n        title: track.title, \n        subtitle: track.artist,\n        id: track.id \n      })),\n      ...data.playlists.map((playlist: any) => ({ \n        type: 'playlist', \n        title: playlist.name, \n        subtitle: `${playlist.trackCount} tracks`,\n        id: playlist.id \n      })),\n      ...data.blogs.map((blog: any) => ({ \n        type: 'blog', \n        title: blog.title, \n        subtitle: blog.authorName,\n        id: blog.id \n      }))\n    ];\n    \n    return allSuggestions.slice(0, 8); // Limit to 8 suggestions\n  }, [data]);\n\n  return {\n    suggestions,\n    isLoading,\n    hasResults: suggestions.length > 0\n  };\n}\n\n// Hook for search with debouncing\nexport function useDebouncedSearch(query: string, delay = 300) {\n  const [debouncedQuery, setDebouncedQuery] = useState(query);\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedQuery(query);\n    }, delay);\n\n    return () => clearTimeout(timer);\n  }, [query, delay]);\n\n  return useSearch({ query: debouncedQuery });\n}\n"