import { useEffect, useState, RefObject } from 'react';\n\ninterface UseIntersectionObserverProps {\n  elementRef: RefObject<Element>;\n  threshold?: number | number[];\n  root?: Element | null;\n  rootMargin?: string;\n  freezeOnceVisible?: boolean;\n}\n\ninterface UseIntersectionObserverReturn {\n  isIntersecting: boolean;\n  entry: IntersectionObserverEntry | null;\n}\n\n/**\n * Hook to observe when an element enters or leaves the viewport\n * Useful for lazy loading, animations, and infinite scrolling\n */\nexport function useIntersectionObserver({\n  elementRef,\n  threshold = 0,\n  root = null,\n  rootMargin = '0px',\n  freezeOnceVisible = false,\n}: UseIntersectionObserverProps): UseIntersectionObserverReturn {\n  const [entry, setEntry] = useState<IntersectionObserverEntry | null>(null);\n  const [isIntersecting, setIsIntersecting] = useState(false);\n\n  useEffect(() => {\n    const element = elementRef.current;\n    const hasIOSupport = !!window.IntersectionObserver;\n\n    if (!hasIOSupport || !element) {\n      // Fallback: assume element is visible if IntersectionObserver is not supported\n      setIsIntersecting(true);\n      return;\n    }\n\n    // If freezeOnceVisible is true and element is already visible, don't observe\n    if (freezeOnceVisible && isIntersecting) {\n      return;\n    }\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        setEntry(entry);\n        setIsIntersecting(entry.isIntersecting);\n        \n        // If freezeOnceVisible is true and element becomes visible, disconnect observer\n        if (freezeOnceVisible && entry.isIntersecting) {\n          observer.disconnect();\n        }\n      },\n      {\n        threshold,\n        root,\n        rootMargin,\n      }\n    );\n\n    observer.observe(element);\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [elementRef, threshold, root, rootMargin, freezeOnceVisible, isIntersecting]);\n\n  return { isIntersecting, entry };\n}\n\nexport default useIntersectionObserver;\n"}