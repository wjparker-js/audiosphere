import { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useUI } from '@/hooks/useUI';\n\ninterface CreateBlogPostData {\n  title: string;\n  content: string;\n  excerpt?: string;\n  status?: 'draft' | 'published';\n}\n\ninterface UpdateBlogPostData {\n  id: number;\n  title?: string;\n  content?: string;\n  excerpt?: string;\n  status?: 'draft' | 'published';\n}\n\ninterface CreateCommentData {\n  blogPostId: number;\n  content: string;\n  parentCommentId?: number;\n}\n\n/**\n * Mutations for blog-related operations\n */\nexport function useBlogMutations() {\n  const queryClient = useQueryClient();\n  const { notifySuccess, notifyError } = useUI();\n\n  // Create blog post mutation\n  const createBlogPostMutation = useMutation({\n    mutationFn: async (data: CreateBlogPostData) => {\n      const response = await fetch('/api/blog', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(data),\n        credentials: 'include',\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to create blog post');\n      }\n\n      return response.json();\n    },\n    onSuccess: (data, variables) => {\n      notifySuccess(\n        variables.status === 'published'\n          ? 'Blog post published successfully!'\n          : 'Blog post saved as draft!'\n      );\n      // Invalidate blog posts queries\n      queryClient.invalidateQueries({ queryKey: ['blog-posts'] });\n    },\n    onError: () => {\n      notifyError('Failed to create blog post');\n    },\n  });\n\n  // Update blog post mutation\n  const updateBlogPostMutation = useMutation({\n    mutationFn: async ({ id, ...data }: UpdateBlogPostData) => {\n      const response = await fetch(`/api/blog/${id}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(data),\n        credentials: 'include',\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to update blog post');\n      }\n\n      return response.json();\n    },\n    onMutate: async ({ id, ...updates }) => {\n      // Cancel any outgoing refetches\n      await queryClient.cancelQueries({ queryKey: ['blog-posts'] });\n      await queryClient.cancelQueries({ queryKey: ['blog-post', id] });\n\n      // Snapshot the previous values\n      const previousBlogPosts = queryClient.getQueryData(['blog-posts']);\n      const previousBlogPost = queryClient.getQueryData(['blog-post', id]);\n\n      // Optimistically update the blog post\n      queryClient.setQueryData(['blog-posts'], (old: any) => {\n        if (!old?.data?.posts) return old;\n        return {\n          ...old,\n          data: {\n            ...old.data,\n            posts: old.data.posts.map((post: any) =>\n              post.id === id ? { ...post, ...updates } : post\n            ),\n          },\n        };\n      });\n\n      queryClient.setQueryData(['blog-post', id], (old: any) => {\n        if (!old?.data?.post) return old;\n        return {\n          ...old,\n          data: {\n            ...old.data,\n            post: { ...old.data.post, ...updates },\n          },\n        };\n      });\n\n      return { previousBlogPosts, previousBlogPost };\n    },\n    onError: (err, { id }, context) => {\n      // Revert optimistic updates on error\n      if (context?.previousBlogPosts) {\n        queryClient.setQueryData(['blog-posts'], context.previousBlogPosts);\n      }\n      if (context?.previousBlogPost) {\n        queryClient.setQueryData(['blog-post', id], context.previousBlogPost);\n      }\n      notifyError('Failed to update blog post');\n    },\n    onSuccess: (data, { status }) => {\n      notifySuccess(\n        status === 'published'\n          ? 'Blog post published successfully!'\n          : 'Blog post updated successfully!'\n      );\n    },\n    onSettled: () => {\n      // Always refetch after error or success\n      queryClient.invalidateQueries({ queryKey: ['blog-posts'] });\n    },\n  });\n\n  // Delete blog post mutation\n  const deleteBlogPostMutation = useMutation({\n    mutationFn: async (id: number) => {\n      const response = await fetch(`/api/blog/${id}`, {\n        method: 'DELETE',\n        credentials: 'include',\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to delete blog post');\n      }\n\n      return response.json();\n    },\n    onMutate: async (id) => {\n      // Cancel any outgoing refetches\n      await queryClient.cancelQueries({ queryKey: ['blog-posts'] });\n\n      // Snapshot the previous value\n      const previousBlogPosts = queryClient.getQueryData(['blog-posts']);\n\n      // Optimistically remove the blog post\n      queryClient.setQueryData(['blog-posts'], (old: any) => {\n        if (!old?.data?.posts) return old;\n        return {\n          ...old,\n          data: {\n            ...old.data,\n            posts: old.data.posts.filter((post: any) => post.id !== id),\n          },\n        };\n      });\n\n      // Remove the individual blog post query\n      queryClient.removeQueries({ queryKey: ['blog-post', id] });\n\n      return { previousBlogPosts };\n    },\n    onError: (err, id, context) => {\n      // Revert optimistic update on error\n      if (context?.previousBlogPosts) {\n        queryClient.setQueryData(['blog-posts'], context.previousBlogPosts);\n      }\n      notifyError('Failed to delete blog post');\n    },\n    onSuccess: () => {\n      notifySuccess('Blog post deleted successfully!');\n    },\n    onSettled: () => {\n      // Always refetch after error or success\n      queryClient.invalidateQueries({ queryKey: ['blog-posts'] });\n    },\n  });\n\n  // Create comment mutation\n  const createCommentMutation = useMutation({\n    mutationFn: async (data: CreateCommentData) => {\n      const response = await fetch('/api/comments', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(data),\n        credentials: 'include',\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to create comment');\n      }\n\n      return response.json();\n    },\n    onMutate: async (newComment) => {\n      // Cancel any outgoing refetches\n      await queryClient.cancelQueries({ queryKey: ['blog-post', newComment.blogPostId] });\n      await queryClient.cancelQueries({ queryKey: ['comments', newComment.blogPostId] });\n\n      // Snapshot the previous values\n      const previousBlogPost = queryClient.getQueryData(['blog-post', newComment.blogPostId]);\n      const previousComments = queryClient.getQueryData(['comments', newComment.blogPostId]);\n\n      // Optimistically add the new comment\n      const optimisticComment = {\n        id: Date.now(), // Temporary ID\n        ...newComment,\n        userId: 1, // Will be updated with real data\n        userName: 'You',\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        commentLevel: newComment.parentCommentId ? 2 : 1,\n      };\n\n      queryClient.setQueryData(['comments', newComment.blogPostId], (old: any) => {\n        if (!old?.data?.comments) return old;\n        return {\n          ...old,\n          data: {\n            ...old.data,\n            comments: [...old.data.comments, optimisticComment],\n          },\n        };\n      });\n\n      return { previousBlogPost, previousComments };\n    },\n    onError: (err, newComment, context) => {\n      // Revert optimistic updates on error\n      if (context?.previousBlogPost) {\n        queryClient.setQueryData(['blog-post', newComment.blogPostId], context.previousBlogPost);\n      }\n      if (context?.previousComments) {\n        queryClient.setQueryData(['comments', newComment.blogPostId], context.previousComments);\n      }\n      notifyError('Failed to post comment');\n    },\n    onSuccess: () => {\n      notifySuccess('Comment posted successfully!');\n    },\n    onSettled: (data, error, variables) => {\n      // Always refetch after error or success\n      queryClient.invalidateQueries({ queryKey: ['blog-post', variables.blogPostId] });\n      queryClient.invalidateQueries({ queryKey: ['comments', variables.blogPostId] });\n    },\n  });\n\n  // Delete comment mutation\n  const deleteCommentMutation = useMutation({\n    mutationFn: async ({ commentId, blogPostId }: { commentId: number; blogPostId: number }) => {\n      const response = await fetch(`/api/comments/${commentId}`, {\n        method: 'DELETE',\n        credentials: 'include',\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to delete comment');\n      }\n\n      return response.json();\n    },\n    onMutate: async ({ commentId, blogPostId }) => {\n      // Cancel any outgoing refetches\n      await queryClient.cancelQueries({ queryKey: ['comments', blogPostId] });\n\n      // Snapshot the previous value\n      const previousComments = queryClient.getQueryData(['comments', blogPostId]);\n\n      // Optimistically remove the comment\n      queryClient.setQueryData(['comments', blogPostId], (old: any) => {\n        if (!old?.data?.comments) return old;\n        return {\n          ...old,\n          data: {\n            ...old.data,\n            comments: old.data.comments.filter((comment: any) => comment.id !== commentId),\n          },\n        };\n      });\n\n      return { previousComments };\n    },\n    onError: (err, { blogPostId }, context) => {\n      // Revert optimistic update on error\n      if (context?.previousComments) {\n        queryClient.setQueryData(['comments', blogPostId], context.previousComments);\n      }\n      notifyError('Failed to delete comment');\n    },\n    onSuccess: () => {\n      notifySuccess('Comment deleted successfully!');\n    },\n    onSettled: (data, error, { blogPostId }) => {\n      // Always refetch after error or success\n      queryClient.invalidateQueries({ queryKey: ['comments', blogPostId] });\n    },\n  });\n\n  return {\n    // Create blog post\n    createBlogPost: createBlogPostMutation.mutate,\n    createBlogPostAsync: createBlogPostMutation.mutateAsync,\n    isCreatingBlogPost: createBlogPostMutation.isPending,\n    \n    // Update blog post\n    updateBlogPost: updateBlogPostMutation.mutate,\n    updateBlogPostAsync: updateBlogPostMutation.mutateAsync,\n    isUpdatingBlogPost: updateBlogPostMutation.isPending,\n    \n    // Delete blog post\n    deleteBlogPost: deleteBlogPostMutation.mutate,\n    deleteBlogPostAsync: deleteBlogPostMutation.mutateAsync,\n    isDeletingBlogPost: deleteBlogPostMutation.isPending,\n    \n    // Create comment\n    createComment: createCommentMutation.mutate,\n    createCommentAsync: createCommentMutation.mutateAsync,\n    isCreatingComment: createCommentMutation.isPending,\n    \n    // Delete comment\n    deleteComment: deleteCommentMutation.mutate,\n    deleteCommentAsync: deleteCommentMutation.mutateAsync,\n    isDeletingComment: deleteCommentMutation.isPending,\n  };\n}\n\nexport default useBlogMutations;\n"}