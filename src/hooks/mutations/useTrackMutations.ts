import { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useUI } from '@/hooks/useUI';\nimport { Track } from '@/types/music';\n\n/**\n * Mutations for track-related operations\n */\nexport function useTrackMutations() {\n  const queryClient = useQueryClient();\n  const { notifySuccess, notifyError } = useUI();\n\n  // Like/Unlike track mutation\n  const likeTrackMutation = useMutation({\n    mutationFn: async ({ trackId, isLiked }: { trackId: number; isLiked: boolean }) => {\n      const response = await fetch(`/api/tracks/${trackId}/like`, {\n        method: isLiked ? 'DELETE' : 'POST',\n        credentials: 'include',\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to update track like status');\n      }\n\n      return response.json();\n    },\n    onMutate: async ({ trackId, isLiked }) => {\n      // Cancel any outgoing refetches\n      await queryClient.cancelQueries({ queryKey: ['tracks'] });\n      await queryClient.cancelQueries({ queryKey: ['track', trackId] });\n\n      // Snapshot the previous values\n      const previousTracks = queryClient.getQueryData(['tracks']);\n      const previousTrack = queryClient.getQueryData(['track', trackId]);\n\n      // Optimistically update the track like status\n      queryClient.setQueryData(['tracks'], (old: any) => {\n        if (!old?.data?.tracks) return old;\n        return {\n          ...old,\n          data: {\n            ...old.data,\n            tracks: old.data.tracks.map((track: Track) =>\n              track.id === trackId ? { ...track, isLiked: !isLiked } : track\n            ),\n          },\n        };\n      });\n\n      queryClient.setQueryData(['track', trackId], (old: any) => {\n        if (!old?.data?.track) return old;\n        return {\n          ...old,\n          data: {\n            ...old.data,\n            track: { ...old.data.track, isLiked: !isLiked },\n          },\n        };\n      });\n\n      return { previousTracks, previousTrack };\n    },\n    onError: (err, { trackId }, context) => {\n      // Revert optimistic updates on error\n      if (context?.previousTracks) {\n        queryClient.setQueryData(['tracks'], context.previousTracks);\n      }\n      if (context?.previousTrack) {\n        queryClient.setQueryData(['track', trackId], context.previousTrack);\n      }\n      notifyError('Failed to update track like status');\n    },\n    onSuccess: (data, { isLiked }) => {\n      notifySuccess(isLiked ? 'Track removed from favorites' : 'Track added to favorites');\n    },\n    onSettled: () => {\n      // Always refetch after error or success\n      queryClient.invalidateQueries({ queryKey: ['tracks'] });\n      queryClient.invalidateQueries({ queryKey: ['user-likes'] });\n    },\n  });\n\n  // Update track play count mutation\n  const updatePlayCountMutation = useMutation({\n    mutationFn: async (trackId: number) => {\n      const response = await fetch(`/api/tracks/${trackId}/play`, {\n        method: 'POST',\n        credentials: 'include',\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to update play count');\n      }\n\n      return response.json();\n    },\n    onMutate: async (trackId) => {\n      // Cancel any outgoing refetches\n      await queryClient.cancelQueries({ queryKey: ['tracks'] });\n      await queryClient.cancelQueries({ queryKey: ['track', trackId] });\n\n      // Snapshot the previous values\n      const previousTracks = queryClient.getQueryData(['tracks']);\n      const previousTrack = queryClient.getQueryData(['track', trackId]);\n\n      // Optimistically update the play count\n      queryClient.setQueryData(['tracks'], (old: any) => {\n        if (!old?.data?.tracks) return old;\n        return {\n          ...old,\n          data: {\n            ...old.data,\n            tracks: old.data.tracks.map((track: Track) =>\n              track.id === trackId ? { ...track, playCount: track.playCount + 1 } : track\n            ),\n          },\n        };\n      });\n\n      queryClient.setQueryData(['track', trackId], (old: any) => {\n        if (!old?.data?.track) return old;\n        return {\n          ...old,\n          data: {\n            ...old.data,\n            track: { ...old.data.track, playCount: old.data.track.playCount + 1 },\n          },\n        };\n      });\n\n      return { previousTracks, previousTrack };\n    },\n    onError: (err, trackId, context) => {\n      // Revert optimistic updates on error\n      if (context?.previousTracks) {\n        queryClient.setQueryData(['tracks'], context.previousTracks);\n      }\n      if (context?.previousTrack) {\n        queryClient.setQueryData(['track', trackId], context.previousTrack);\n      }\n      // Don't show error notification for play count updates (silent failure)\n    },\n    onSettled: () => {\n      // Refetch tracks to get updated play counts\n      queryClient.invalidateQueries({ queryKey: ['tracks'] });\n    },\n  });\n\n  return {\n    likeTrack: likeTrackMutation.mutate,\n    likeTrackAsync: likeTrackMutation.mutateAsync,\n    isLikingTrack: likeTrackMutation.isPending,\n    \n    updatePlayCount: updatePlayCountMutation.mutate,\n    updatePlayCountAsync: updatePlayCountMutation.mutateAsync,\n    isUpdatingPlayCount: updatePlayCountMutation.isPending,\n  };\n}\n\nexport default useTrackMutations;\n"}