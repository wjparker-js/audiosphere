import { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useUI } from '@/hooks/useUI';\nimport { Playlist } from '@/types/music';\n\ninterface CreatePlaylistData {\n  name: string;\n  description?: string;\n  isPublic?: boolean;\n}\n\ninterface UpdatePlaylistData {\n  id: number;\n  name?: string;\n  description?: string;\n  isPublic?: boolean;\n}\n\n/**\n * Mutations for playlist-related operations\n */\nexport function usePlaylistMutations() {\n  const queryClient = useQueryClient();\n  const { notifySuccess, notifyError } = useUI();\n\n  // Create playlist mutation\n  const createPlaylistMutation = useMutation({\n    mutationFn: async (data: CreatePlaylistData) => {\n      const response = await fetch('/api/playlists', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(data),\n        credentials: 'include',\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to create playlist');\n      }\n\n      return response.json();\n    },\n    onMutate: async (newPlaylist) => {\n      // Cancel any outgoing refetches\n      await queryClient.cancelQueries({ queryKey: ['playlists'] });\n\n      // Snapshot the previous value\n      const previousPlaylists = queryClient.getQueryData(['playlists']);\n\n      // Optimistically add the new playlist\n      const optimisticPlaylist = {\n        id: Date.now(), // Temporary ID\n        ...newPlaylist,\n        trackCount: 0,\n        userId: 1, // Will be updated with real data\n        ownerName: 'You',\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n      };\n\n      queryClient.setQueryData(['playlists'], (old: any) => {\n        if (!old?.data?.playlists) return old;\n        return {\n          ...old,\n          data: {\n            ...old.data,\n            playlists: [...old.data.playlists, optimisticPlaylist],\n          },\n        };\n      });\n\n      return { previousPlaylists };\n    },\n    onError: (err, newPlaylist, context) => {\n      // Revert optimistic update on error\n      if (context?.previousPlaylists) {\n        queryClient.setQueryData(['playlists'], context.previousPlaylists);\n      }\n      notifyError('Failed to create playlist');\n    },\n    onSuccess: (data, variables) => {\n      notifySuccess(`Playlist \"${variables.name}\" created successfully!`);\n    },\n    onSettled: () => {\n      // Always refetch after error or success\n      queryClient.invalidateQueries({ queryKey: ['playlists'] });\n    },\n  });\n\n  // Update playlist mutation\n  const updatePlaylistMutation = useMutation({\n    mutationFn: async ({ id, ...data }: UpdatePlaylistData) => {\n      const response = await fetch(`/api/playlists/${id}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(data),\n        credentials: 'include',\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to update playlist');\n      }\n\n      return response.json();\n    },\n    onMutate: async ({ id, ...updates }) => {\n      // Cancel any outgoing refetches\n      await queryClient.cancelQueries({ queryKey: ['playlists'] });\n      await queryClient.cancelQueries({ queryKey: ['playlist', id] });\n\n      // Snapshot the previous values\n      const previousPlaylists = queryClient.getQueryData(['playlists']);\n      const previousPlaylist = queryClient.getQueryData(['playlist', id]);\n\n      // Optimistically update the playlist\n      queryClient.setQueryData(['playlists'], (old: any) => {\n        if (!old?.data?.playlists) return old;\n        return {\n          ...old,\n          data: {\n            ...old.data,\n            playlists: old.data.playlists.map((playlist: Playlist) =>\n              playlist.id === id ? { ...playlist, ...updates } : playlist\n            ),\n          },\n        };\n      });\n\n      queryClient.setQueryData(['playlist', id], (old: any) => {\n        if (!old?.data?.playlist) return old;\n        return {\n          ...old,\n          data: {\n            ...old.data,\n            playlist: { ...old.data.playlist, ...updates },\n          },\n        };\n      });\n\n      return { previousPlaylists, previousPlaylist };\n    },\n    onError: (err, { id }, context) => {\n      // Revert optimistic updates on error\n      if (context?.previousPlaylists) {\n        queryClient.setQueryData(['playlists'], context.previousPlaylists);\n      }\n      if (context?.previousPlaylist) {\n        queryClient.setQueryData(['playlist', id], context.previousPlaylist);\n      }\n      notifyError('Failed to update playlist');\n    },\n    onSuccess: (data, { name }) => {\n      notifySuccess(`Playlist \"${name}\" updated successfully!`);\n    },\n    onSettled: () => {\n      // Always refetch after error or success\n      queryClient.invalidateQueries({ queryKey: ['playlists'] });\n    },\n  });\n\n  // Delete playlist mutation\n  const deletePlaylistMutation = useMutation({\n    mutationFn: async (id: number) => {\n      const response = await fetch(`/api/playlists/${id}`, {\n        method: 'DELETE',\n        credentials: 'include',\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to delete playlist');\n      }\n\n      return response.json();\n    },\n    onMutate: async (id) => {\n      // Cancel any outgoing refetches\n      await queryClient.cancelQueries({ queryKey: ['playlists'] });\n\n      // Snapshot the previous value\n      const previousPlaylists = queryClient.getQueryData(['playlists']);\n\n      // Optimistically remove the playlist\n      queryClient.setQueryData(['playlists'], (old: any) => {\n        if (!old?.data?.playlists) return old;\n        return {\n          ...old,\n          data: {\n            ...old.data,\n            playlists: old.data.playlists.filter((playlist: Playlist) => playlist.id !== id),\n          },\n        };\n      });\n\n      // Remove the individual playlist query\n      queryClient.removeQueries({ queryKey: ['playlist', id] });\n\n      return { previousPlaylists };\n    },\n    onError: (err, id, context) => {\n      // Revert optimistic update on error\n      if (context?.previousPlaylists) {\n        queryClient.setQueryData(['playlists'], context.previousPlaylists);\n      }\n      notifyError('Failed to delete playlist');\n    },\n    onSuccess: () => {\n      notifySuccess('Playlist deleted successfully!');\n    },\n    onSettled: () => {\n      // Always refetch after error or success\n      queryClient.invalidateQueries({ queryKey: ['playlists'] });\n    },\n  });\n\n  // Add track to playlist mutation\n  const addTrackToPlaylistMutation = useMutation({\n    mutationFn: async ({ playlistId, trackId }: { playlistId: number; trackId: number }) => {\n      const response = await fetch(`/api/playlists/${playlistId}/tracks`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ trackId }),\n        credentials: 'include',\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to add track to playlist');\n      }\n\n      return response.json();\n    },\n    onMutate: async ({ playlistId, trackId }) => {\n      // Cancel any outgoing refetches\n      await queryClient.cancelQueries({ queryKey: ['playlists'] });\n      await queryClient.cancelQueries({ queryKey: ['playlist', playlistId] });\n\n      // Snapshot the previous values\n      const previousPlaylists = queryClient.getQueryData(['playlists']);\n      const previousPlaylist = queryClient.getQueryData(['playlist', playlistId]);\n\n      // Optimistically update the playlist track count\n      queryClient.setQueryData(['playlists'], (old: any) => {\n        if (!old?.data?.playlists) return old;\n        return {\n          ...old,\n          data: {\n            ...old.data,\n            playlists: old.data.playlists.map((playlist: Playlist) =>\n              playlist.id === playlistId\n                ? { ...playlist, trackCount: playlist.trackCount + 1 }\n                : playlist\n            ),\n          },\n        };\n      });\n\n      return { previousPlaylists, previousPlaylist };\n    },\n    onError: (err, { playlistId }, context) => {\n      // Revert optimistic updates on error\n      if (context?.previousPlaylists) {\n        queryClient.setQueryData(['playlists'], context.previousPlaylists);\n      }\n      if (context?.previousPlaylist) {\n        queryClient.setQueryData(['playlist', playlistId], context.previousPlaylist);\n      }\n      notifyError('Failed to add track to playlist');\n    },\n    onSuccess: () => {\n      notifySuccess('Track added to playlist!');\n    },\n    onSettled: (data, error, { playlistId }) => {\n      // Always refetch after error or success\n      queryClient.invalidateQueries({ queryKey: ['playlists'] });\n      queryClient.invalidateQueries({ queryKey: ['playlist', playlistId] });\n    },\n  });\n\n  // Remove track from playlist mutation\n  const removeTrackFromPlaylistMutation = useMutation({\n    mutationFn: async ({ playlistId, trackId }: { playlistId: number; trackId: number }) => {\n      const response = await fetch(`/api/playlists/${playlistId}/tracks/${trackId}`, {\n        method: 'DELETE',\n        credentials: 'include',\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to remove track from playlist');\n      }\n\n      return response.json();\n    },\n    onMutate: async ({ playlistId, trackId }) => {\n      // Cancel any outgoing refetches\n      await queryClient.cancelQueries({ queryKey: ['playlists'] });\n      await queryClient.cancelQueries({ queryKey: ['playlist', playlistId] });\n\n      // Snapshot the previous values\n      const previousPlaylists = queryClient.getQueryData(['playlists']);\n      const previousPlaylist = queryClient.getQueryData(['playlist', playlistId]);\n\n      // Optimistically update the playlist track count\n      queryClient.setQueryData(['playlists'], (old: any) => {\n        if (!old?.data?.playlists) return old;\n        return {\n          ...old,\n          data: {\n            ...old.data,\n            playlists: old.data.playlists.map((playlist: Playlist) =>\n              playlist.id === playlistId\n                ? { ...playlist, trackCount: Math.max(0, playlist.trackCount - 1) }\n                : playlist\n            ),\n          },\n        };\n      });\n\n      return { previousPlaylists, previousPlaylist };\n    },\n    onError: (err, { playlistId }, context) => {\n      // Revert optimistic updates on error\n      if (context?.previousPlaylists) {\n        queryClient.setQueryData(['playlists'], context.previousPlaylists);\n      }\n      if (context?.previousPlaylist) {\n        queryClient.setQueryData(['playlist', playlistId], context.previousPlaylist);\n      }\n      notifyError('Failed to remove track from playlist');\n    },\n    onSuccess: () => {\n      notifySuccess('Track removed from playlist!');\n    },\n    onSettled: (data, error, { playlistId }) => {\n      // Always refetch after error or success\n      queryClient.invalidateQueries({ queryKey: ['playlists'] });\n      queryClient.invalidateQueries({ queryKey: ['playlist', playlistId] });\n    },\n  });\n\n  return {\n    // Create playlist\n    createPlaylist: createPlaylistMutation.mutate,\n    createPlaylistAsync: createPlaylistMutation.mutateAsync,\n    isCreatingPlaylist: createPlaylistMutation.isPending,\n    \n    // Update playlist\n    updatePlaylist: updatePlaylistMutation.mutate,\n    updatePlaylistAsync: updatePlaylistMutation.mutateAsync,\n    isUpdatingPlaylist: updatePlaylistMutation.isPending,\n    \n    // Delete playlist\n    deletePlaylist: deletePlaylistMutation.mutate,\n    deletePlaylistAsync: deletePlaylistMutation.mutateAsync,\n    isDeletingPlaylist: deletePlaylistMutation.isPending,\n    \n    // Add track to playlist\n    addTrackToPlaylist: addTrackToPlaylistMutation.mutate,\n    addTrackToPlaylistAsync: addTrackToPlaylistMutation.mutateAsync,\n    isAddingTrackToPlaylist: addTrackToPlaylistMutation.isPending,\n    \n    // Remove track from playlist\n    removeTrackFromPlaylist: removeTrackFromPlaylistMutation.mutate,\n    removeTrackFromPlaylistAsync: removeTrackFromPlaylistMutation.mutateAsync,\n    isRemovingTrackFromPlaylist: removeTrackFromPlaylistMutation.isPending,\n  };\n}\n\nexport default usePlaylistMutations;\n"}