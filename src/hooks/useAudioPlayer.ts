import { useState, useEffect, useRef, useCallback } from 'react';\nimport { AudioStreamingPlayer, AudioTrack, AudioPlayerState } from '@/lib/audio-processing';\nimport { useUserPreferences } from '@/hooks/useUserPreferences';\nimport { useUI } from '@/hooks/useUI';\n\ninterface UseAudioPlayerOptions {\n  enableCrossfade?: boolean;\n  crossfadeDuration?: number;\n  enableQualityAdaptation?: boolean;\n  preloadNext?: boolean;\n}\n\ninterface UseAudioPlayerReturn {\n  // Player state\n  currentTrack: AudioTrack | null;\n  playerState: AudioPlayerState;\n  isPlaying: boolean;\n  isLoading: boolean;\n  error: string | null;\n  \n  // Playback controls\n  play: () => Promise<void>;\n  pause: () => Promise<void>;\n  togglePlay: () => Promise<void>;\n  seek: (time: number) => void;\n  setVolume: (volume: number) => void;\n  setPlaybackRate: (rate: number) => void;\n  \n  // Track management\n  loadTrack: (track: AudioTrack, autoPlay?: boolean) => Promise<void>;\n  preloadTrack: (track: AudioTrack) => void;\n  \n  // Quality control\n  changeQuality: (quality: keyof AudioTrack['sources']) => Promise<void>;\n  getCurrentQuality: () => keyof AudioTrack['sources'];\n  \n  // Advanced features\n  enableCrossfade: (enabled: boolean, duration?: number) => void;\n  getBufferHealth: () => { buffered: number; ahead: number };\n  \n  // Event handlers\n  addEventListener: (event: string, callback: Function) => void;\n  removeEventListener: (event: string, callback: Function) => void;\n}\n\n/**\n * Enhanced audio player hook with streaming optimization\n */\nexport function useAudioPlayer(options: UseAudioPlayerOptions = {}): UseAudioPlayerReturn {\n  const {\n    enableCrossfade = true,\n    crossfadeDuration = 3000,\n    enableQualityAdaptation = true,\n    preloadNext = true,\n  } = options;\n\n  // State\n  const [currentTrack, setCurrentTrack] = useState<AudioTrack | null>(null);\n  const [playerState, setPlayerState] = useState<AudioPlayerState>({\n    currentTime: 0,\n    duration: 0,\n    buffered: null,\n    loading: false,\n    error: null,\n    quality: 'medium',\n    volume: 0.7,\n    muted: false,\n    playbackRate: 1,\n  });\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // Refs\n  const playerRef = useRef<AudioStreamingPlayer | null>(null);\n  const eventListenersRef = useRef<Map<string, Function[]>>(new Map());\n\n  // Hooks\n  const { preferences, applyAudioPreferences } = useUserPreferences();\n  const { notifyError } = useUI();\n\n  // Initialize player\n  useEffect(() => {\n    if (!playerRef.current) {\n      playerRef.current = new AudioStreamingPlayer();\n      \n      // Apply user preferences\n      applyAudioPreferences(playerRef.current);\n      \n      // Set up event listeners\n      setupEventListeners();\n      \n      // Configure crossfade\n      if (enableCrossfade) {\n        playerRef.current.enableCrossfade(true, crossfadeDuration);\n      }\n    }\n\n    return () => {\n      if (playerRef.current) {\n        playerRef.current.destroy();\n        playerRef.current = null;\n      }\n    };\n  }, []);\n\n  // Apply user preferences when they change\n  useEffect(() => {\n    if (playerRef.current) {\n      applyAudioPreferences(playerRef.current);\n    }\n  }, [preferences, applyAudioPreferences]);\n\n  // Setup event listeners\n  const setupEventListeners = useCallback(() => {\n    if (!playerRef.current) return;\n\n    const player = playerRef.current;\n\n    // Player state events\n    player.addEventListener('play', () => {\n      setIsPlaying(true);\n      setError(null);\n    });\n\n    player.addEventListener('pause', () => {\n      setIsPlaying(false);\n    });\n\n    player.addEventListener('ended', () => {\n      setIsPlaying(false);\n    });\n\n    player.addEventListener('error', (errorData: any) => {\n      const errorMessage = errorData?.message || 'Audio playback error';\n      setError(errorMessage);\n      setIsLoading(false);\n      setIsPlaying(false);\n      notifyError(errorMessage);\n    });\n\n    player.addEventListener('loadstart', () => {\n      setIsLoading(true);\n      setError(null);\n    });\n\n    player.addEventListener('canplay', () => {\n      setIsLoading(false);\n    });\n\n    player.addEventListener('timeupdate', (state: AudioPlayerState) => {\n      setPlayerState(state);\n    });\n\n    player.addEventListener('trackLoaded', ({ track }: { track: AudioTrack }) => {\n      setCurrentTrack(track);\n      setIsLoading(false);\n    });\n\n    player.addEventListener('qualityChanged', ({ quality }: { quality: string }) => {\n      setPlayerState(prev => ({ ...prev, quality: quality as keyof AudioTrack['sources'] }));\n    });\n  }, [notifyError]);\n\n  // Playback controls\n  const play = useCallback(async () => {\n    if (!playerRef.current) return;\n    \n    try {\n      await playerRef.current.play();\n    } catch (error) {\n      console.error('Play error:', error);\n      setError('Failed to play audio');\n    }\n  }, []);\n\n  const pause = useCallback(async () => {\n    if (!playerRef.current) return;\n    \n    try {\n      await playerRef.current.pause();\n    } catch (error) {\n      console.error('Pause error:', error);\n    }\n  }, []);\n\n  const togglePlay = useCallback(async () => {\n    if (isPlaying) {\n      await pause();\n    } else {\n      await play();\n    }\n  }, [isPlaying, play, pause]);\n\n  const seek = useCallback((time: number) => {\n    if (!playerRef.current) return;\n    playerRef.current.seek(time);\n  }, []);\n\n  const setVolume = useCallback((volume: number) => {\n    if (!playerRef.current) return;\n    playerRef.current.setVolume(volume, true);\n  }, []);\n\n  const setPlaybackRate = useCallback((rate: number) => {\n    if (!playerRef.current) return;\n    playerRef.current.setPlaybackRate(rate);\n  }, []);\n\n  // Track management\n  const loadTrack = useCallback(async (track: AudioTrack, autoPlay = false) => {\n    if (!playerRef.current) return;\n    \n    try {\n      setIsLoading(true);\n      setError(null);\n      await playerRef.current.loadTrack(track, autoPlay);\n    } catch (error) {\n      console.error('Load track error:', error);\n      setError('Failed to load track');\n      setIsLoading(false);\n    }\n  }, []);\n\n  const preloadTrack = useCallback((track: AudioTrack) => {\n    if (!playerRef.current || !preloadNext) return;\n    playerRef.current.preloadTrack(track);\n  }, [preloadNext]);\n\n  // Quality control\n  const changeQuality = useCallback(async (quality: keyof AudioTrack['sources']) => {\n    if (!playerRef.current) return;\n    \n    try {\n      await playerRef.current.changeQuality(quality);\n    } catch (error) {\n      console.error('Change quality error:', error);\n      setError('Failed to change audio quality');\n    }\n  }, []);\n\n  const getCurrentQuality = useCallback((): keyof AudioTrack['sources'] => {\n    return playerState.quality;\n  }, [playerState.quality]);\n\n  // Advanced features\n  const enableCrossfadeControl = useCallback((enabled: boolean, duration = 3000) => {\n    if (!playerRef.current) return;\n    playerRef.current.enableCrossfade(enabled, duration);\n  }, []);\n\n  const getBufferHealth = useCallback(() => {\n    if (!playerRef.current || !playerState.buffered) {\n      return { buffered: 0, ahead: 0 };\n    }\n\n    const buffered = playerState.buffered;\n    const currentTime = playerState.currentTime;\n    \n    let totalBuffered = 0;\n    let bufferAhead = 0;\n\n    for (let i = 0; i < buffered.length; i++) {\n      const start = buffered.start(i);\n      const end = buffered.end(i);\n      totalBuffered += end - start;\n      \n      if (currentTime >= start && currentTime <= end) {\n        bufferAhead = end - currentTime;\n      }\n    }\n\n    return {\n      buffered: totalBuffered,\n      ahead: bufferAhead,\n    };\n  }, [playerState.buffered, playerState.currentTime]);\n\n  // Event management\n  const addEventListener = useCallback((event: string, callback: Function) => {\n    if (!eventListenersRef.current.has(event)) {\n      eventListenersRef.current.set(event, []);\n    }\n    eventListenersRef.current.get(event)!.push(callback);\n    \n    // Also add to the actual player\n    if (playerRef.current) {\n      playerRef.current.addEventListener(event, callback);\n    }\n  }, []);\n\n  const removeEventListener = useCallback((event: string, callback: Function) => {\n    const listeners = eventListenersRef.current.get(event);\n    if (listeners) {\n      const index = listeners.indexOf(callback);\n      if (index > -1) {\n        listeners.splice(index, 1);\n      }\n    }\n    \n    // Also remove from the actual player\n    if (playerRef.current) {\n      playerRef.current.removeEventListener(event, callback);\n    }\n  }, []);\n\n  return {\n    // Player state\n    currentTrack,\n    playerState,\n    isPlaying,\n    isLoading,\n    error,\n    \n    // Playback controls\n    play,\n    pause,\n    togglePlay,\n    seek,\n    setVolume,\n    setPlaybackRate,\n    \n    // Track management\n    loadTrack,\n    preloadTrack,\n    \n    // Quality control\n    changeQuality,\n    getCurrentQuality,\n    \n    // Advanced features\n    enableCrossfade: enableCrossfadeControl,\n    getBufferHealth,\n    \n    // Event handlers\n    addEventListener,\n    removeEventListener,\n  };\n}\n\nexport default useAudioPlayer;\n"}