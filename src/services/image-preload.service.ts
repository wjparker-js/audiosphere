/**\n * Image preloading service for AudioSphere\n * Handles intelligent image preloading based on user behavior and viewport\n */\n\nexport interface PreloadOptions {\n  priority?: 'high' | 'medium' | 'low';\n  timeout?: number;\n  retries?: number;\n  onLoad?: () => void;\n  onError?: (error: Error) => void;\n}\n\nexport interface PreloadQueueItem {\n  src: string;\n  options: PreloadOptions;\n  attempts: number;\n  timestamp: number;\n}\n\nclass ImagePreloadService {\n  private cache = new Map<string, boolean>();\n  private loading = new Set<string>();\n  private queue: PreloadQueueItem[] = [];\n  private isProcessing = false;\n  private maxConcurrent = 3;\n  private currentLoading = 0;\n\n  /**\n   * Preload a single image\n   */\n  async preload(\n    src: string,\n    options: PreloadOptions = {}\n  ): Promise<void> {\n    const {\n      priority = 'medium',\n      timeout = 10000,\n      retries = 2,\n      onLoad,\n      onError,\n    } = options;\n\n    // Check if already cached\n    if (this.cache.has(src)) {\n      onLoad?.();\n      return;\n    }\n\n    // Check if already loading\n    if (this.loading.has(src)) {\n      return;\n    }\n\n    // Add to queue based on priority\n    const queueItem: PreloadQueueItem = {\n      src,\n      options: { priority, timeout, retries, onLoad, onError },\n      attempts: 0,\n      timestamp: Date.now(),\n    };\n\n    this.addToQueue(queueItem);\n    this.processQueue();\n  }\n\n  /**\n   * Preload multiple images\n   */\n  async preloadMultiple(\n    sources: string[],\n    options: PreloadOptions = {}\n  ): Promise<void> {\n    const promises = sources.map(src => this.preload(src, options));\n    await Promise.allSettled(promises);\n  }\n\n  /**\n   * Preload images based on viewport intersection\n   */\n  preloadOnIntersection(\n    elements: Element[],\n    options: PreloadOptions & { rootMargin?: string; threshold?: number } = {}\n  ): () => void {\n    const { rootMargin = '50px', threshold = 0.1, ...preloadOptions } = options;\n\n    const observer = new IntersectionObserver(\n      (entries) => {\n        entries.forEach((entry) => {\n          if (entry.isIntersecting) {\n            const img = entry.target as HTMLImageElement;\n            const src = img.dataset.src || img.src;\n            \n            if (src) {\n              this.preload(src, preloadOptions);\n            }\n            \n            observer.unobserve(entry.target);\n          }\n        });\n      },\n      {\n        rootMargin,\n        threshold,\n      }\n    );\n\n    elements.forEach(el => observer.observe(el));\n\n    // Return cleanup function\n    return () => observer.disconnect();\n  }\n\n  /**\n   * Preload images on hover with debouncing\n   */\n  preloadOnHover(\n    element: Element,\n    src: string,\n    options: PreloadOptions & { delay?: number } = {}\n  ): () => void {\n    const { delay = 100, ...preloadOptions } = options;\n    let timeoutId: NodeJS.Timeout;\n\n    const handleMouseEnter = () => {\n      timeoutId = setTimeout(() => {\n        this.preload(src, preloadOptions);\n      }, delay);\n    };\n\n    const handleMouseLeave = () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n\n    element.addEventListener('mouseenter', handleMouseEnter);\n    element.addEventListener('mouseleave', handleMouseLeave);\n\n    // Return cleanup function\n    return () => {\n      element.removeEventListener('mouseenter', handleMouseEnter);\n      element.removeEventListener('mouseleave', handleMouseLeave);\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n  }\n\n  /**\n   * Preload critical images immediately\n   */\n  preloadCritical(sources: string[]): void {\n    sources.forEach(src => {\n      this.preload(src, { priority: 'high' });\n    });\n  }\n\n  /**\n   * Preload images for next page/route\n   */\n  preloadForRoute(route: string, sources: string[]): void {\n    // Use low priority for route preloading\n    sources.forEach(src => {\n      this.preload(src, { priority: 'low' });\n    });\n  }\n\n  /**\n   * Check if image is cached\n   */\n  isCached(src: string): boolean {\n    return this.cache.has(src);\n  }\n\n  /**\n   * Clear cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): {\n    cached: number;\n    loading: number;\n    queued: number;\n  } {\n    return {\n      cached: this.cache.size,\n      loading: this.loading.size,\n      queued: this.queue.length,\n    };\n  }\n\n  /**\n   * Add item to queue based on priority\n   */\n  private addToQueue(item: PreloadQueueItem): void {\n    const priority = item.options.priority || 'medium';\n    \n    // Insert based on priority\n    let insertIndex = this.queue.length;\n    \n    for (let i = 0; i < this.queue.length; i++) {\n      const queuePriority = this.queue[i].options.priority || 'medium';\n      \n      if (this.getPriorityValue(priority) > this.getPriorityValue(queuePriority)) {\n        insertIndex = i;\n        break;\n      }\n    }\n    \n    this.queue.splice(insertIndex, 0, item);\n  }\n\n  /**\n   * Get numeric value for priority comparison\n   */\n  private getPriorityValue(priority: string): number {\n    switch (priority) {\n      case 'high': return 3;\n      case 'medium': return 2;\n      case 'low': return 1;\n      default: return 2;\n    }\n  }\n\n  /**\n   * Process the preload queue\n   */\n  private async processQueue(): Promise<void> {\n    if (this.isProcessing || this.currentLoading >= this.maxConcurrent) {\n      return;\n    }\n\n    this.isProcessing = true;\n\n    while (this.queue.length > 0 && this.currentLoading < this.maxConcurrent) {\n      const item = this.queue.shift();\n      if (!item) break;\n\n      this.loadImage(item);\n    }\n\n    this.isProcessing = false;\n  }\n\n  /**\n   * Load individual image\n   */\n  private async loadImage(item: PreloadQueueItem): Promise<void> {\n    const { src, options } = item;\n    \n    // Skip if already cached or loading\n    if (this.cache.has(src) || this.loading.has(src)) {\n      return;\n    }\n\n    this.loading.add(src);\n    this.currentLoading++;\n\n    try {\n      await this.loadImagePromise(src, options.timeout || 10000);\n      \n      // Mark as cached\n      this.cache.set(src, true);\n      options.onLoad?.();\n      \n    } catch (error) {\n      // Retry if attempts remaining\n      if (item.attempts < (options.retries || 2)) {\n        item.attempts++;\n        this.addToQueue(item);\n      } else {\n        options.onError?.(error as Error);\n      }\n    } finally {\n      this.loading.delete(src);\n      this.currentLoading--;\n      \n      // Continue processing queue\n      this.processQueue();\n    }\n  }\n\n  /**\n   * Create promise for image loading with timeout\n   */\n  private loadImagePromise(src: string, timeout: number): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      let timeoutId: NodeJS.Timeout;\n\n      const cleanup = () => {\n        if (timeoutId) clearTimeout(timeoutId);\n        img.onload = null;\n        img.onerror = null;\n      };\n\n      img.onload = () => {\n        cleanup();\n        resolve();\n      };\n\n      img.onerror = () => {\n        cleanup();\n        reject(new Error(`Failed to load image: ${src}`));\n      };\n\n      // Set timeout\n      timeoutId = setTimeout(() => {\n        cleanup();\n        reject(new Error(`Image load timeout: ${src}`));\n      }, timeout);\n\n      img.src = src;\n    });\n  }\n\n  /**\n   * Intelligent preloading based on user behavior\n   */\n  enableIntelligentPreloading(): void {\n    // Preload on mouse movement (user is active)\n    let mouseMoveTimeout: NodeJS.Timeout;\n    \n    const handleMouseMove = () => {\n      if (mouseMoveTimeout) clearTimeout(mouseMoveTimeout);\n      \n      mouseMoveTimeout = setTimeout(() => {\n        // User stopped moving, preload visible images\n        this.preloadVisibleImages();\n      }, 500);\n    };\n\n    // Preload on scroll end\n    let scrollTimeout: NodeJS.Timeout;\n    \n    const handleScroll = () => {\n      if (scrollTimeout) clearTimeout(scrollTimeout);\n      \n      scrollTimeout = setTimeout(() => {\n        this.preloadVisibleImages();\n      }, 300);\n    };\n\n    // Preload on idle\n    const handleIdle = () => {\n      this.preloadVisibleImages();\n    };\n\n    document.addEventListener('mousemove', handleMouseMove, { passive: true });\n    document.addEventListener('scroll', handleScroll, { passive: true });\n    \n    // Use requestIdleCallback if available\n    if ('requestIdleCallback' in window) {\n      requestIdleCallback(handleIdle);\n    }\n  }\n\n  /**\n   * Preload images that are currently visible or near viewport\n   */\n  private preloadVisibleImages(): void {\n    const images = document.querySelectorAll('img[data-src], img[loading=\"lazy\"]');\n    \n    images.forEach((img) => {\n      const rect = img.getBoundingClientRect();\n      const isNearViewport = rect.top < window.innerHeight + 200 && rect.bottom > -200;\n      \n      if (isNearViewport) {\n        const src = (img as HTMLImageElement).dataset.src || (img as HTMLImageElement).src;\n        if (src) {\n          this.preload(src, { priority: 'low' });\n        }\n      }\n    });\n  }\n}\n\n// Export singleton instance\nexport const imagePreloadService = new ImagePreloadService();\n\n// Auto-enable intelligent preloading in browser environment\nif (typeof window !== 'undefined') {\n  // Enable after page load\n  if (document.readyState === 'complete') {\n    imagePreloadService.enableIntelligentPreloading();\n  } else {\n    window.addEventListener('load', () => {\n      imagePreloadService.enableIntelligentPreloading();\n    });\n  }\n}\n\nexport default imagePreloadService;\n"}