/**\n * Audio streaming service for AudioSphere\n * Handles server-side audio streaming, range requests, and format conversion\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { createReadStream, statSync } from 'fs';\nimport { join } from 'path';\n\nexport interface StreamingOptions {\n  quality?: 'low' | 'medium' | 'high' | 'lossless';\n  format?: 'mp3' | 'aac' | 'ogg' | 'webm';\n  bitrate?: number;\n  enableRangeRequests?: boolean;\n  enableCaching?: boolean;\n  chunkSize?: number;\n}\n\nexport interface AudioMetadata {\n  duration: number;\n  bitrate: number;\n  sampleRate: number;\n  channels: number;\n  format: string;\n  size: number;\n}\n\n/**\n * Audio streaming service class\n */\nexport class AudioStreamingService {\n  private static instance: AudioStreamingService;\n  private uploadPath: string;\n  private supportedFormats = ['mp3', 'aac', 'ogg', 'webm', 'm4a', 'wav'];\n  private qualityPresets = {\n    low: { bitrate: 128, format: 'mp3' },\n    medium: { bitrate: 256, format: 'mp3' },\n    high: { bitrate: 320, format: 'mp3' },\n    lossless: { bitrate: 1411, format: 'flac' },\n  };\n\n  constructor() {\n    this.uploadPath = join(process.cwd(), 'public', 'uploads', 'audio');\n  }\n\n  static getInstance(): AudioStreamingService {\n    if (!AudioStreamingService.instance) {\n      AudioStreamingService.instance = new AudioStreamingService();\n    }\n    return AudioStreamingService.instance;\n  }\n\n  /**\n   * Stream audio file with range request support\n   */\n  async streamAudio(\n    request: NextRequest,\n    filePath: string,\n    options: StreamingOptions = {}\n  ): Promise<NextResponse> {\n    const {\n      enableRangeRequests = true,\n      enableCaching = true,\n      chunkSize = 1024 * 1024, // 1MB chunks\n    } = options;\n\n    try {\n      const fullPath = join(this.uploadPath, filePath);\n      const stats = statSync(fullPath);\n      const fileSize = stats.size;\n\n      // Parse range header\n      const range = request.headers.get('range');\n      \n      if (range && enableRangeRequests) {\n        return this.handleRangeRequest(fullPath, range, fileSize, enableCaching);\n      } else {\n        return this.handleFullFileRequest(fullPath, fileSize, enableCaching);\n      }\n    } catch (error) {\n      console.error('Audio streaming error:', error);\n      return new NextResponse('File not found', { status: 404 });\n    }\n  }\n\n  /**\n   * Handle HTTP range requests for audio streaming\n   */\n  private async handleRangeRequest(\n    filePath: string,\n    rangeHeader: string,\n    fileSize: number,\n    enableCaching: boolean\n  ): Promise<NextResponse> {\n    const parts = rangeHeader.replace(/bytes=/, '').split('-');\n    const start = parseInt(parts[0], 10);\n    const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;\n    const chunkSize = (end - start) + 1;\n\n    // Validate range\n    if (start >= fileSize || end >= fileSize) {\n      return new NextResponse('Range Not Satisfiable', {\n        status: 416,\n        headers: {\n          'Content-Range': `bytes */${fileSize}`,\n        },\n      });\n    }\n\n    // Create read stream for the requested range\n    const stream = createReadStream(filePath, { start, end });\n    \n    // Convert Node.js stream to Web Stream\n    const readableStream = new ReadableStream({\n      start(controller) {\n        stream.on('data', (chunk) => {\n          controller.enqueue(new Uint8Array(chunk));\n        });\n        \n        stream.on('end', () => {\n          controller.close();\n        });\n        \n        stream.on('error', (error) => {\n          controller.error(error);\n        });\n      },\n      \n      cancel() {\n        stream.destroy();\n      },\n    });\n\n    const headers = new Headers({\n      'Content-Range': `bytes ${start}-${end}/${fileSize}`,\n      'Accept-Ranges': 'bytes',\n      'Content-Length': chunkSize.toString(),\n      'Content-Type': this.getContentType(filePath),\n    });\n\n    if (enableCaching) {\n      headers.set('Cache-Control', 'public, max-age=3600'); // 1 hour\n      headers.set('ETag', `\"${fileSize}-${Math.floor(Date.now() / 1000)}\"`);\n    }\n\n    return new NextResponse(readableStream, {\n      status: 206, // Partial Content\n      headers,\n    });\n  }\n\n  /**\n   * Handle full file requests\n   */\n  private async handleFullFileRequest(\n    filePath: string,\n    fileSize: number,\n    enableCaching: boolean\n  ): Promise<NextResponse> {\n    const stream = createReadStream(filePath);\n    \n    // Convert Node.js stream to Web Stream\n    const readableStream = new ReadableStream({\n      start(controller) {\n        stream.on('data', (chunk) => {\n          controller.enqueue(new Uint8Array(chunk));\n        });\n        \n        stream.on('end', () => {\n          controller.close();\n        });\n        \n        stream.on('error', (error) => {\n          controller.error(error);\n        });\n      },\n      \n      cancel() {\n        stream.destroy();\n      },\n    });\n\n    const headers = new Headers({\n      'Content-Length': fileSize.toString(),\n      'Content-Type': this.getContentType(filePath),\n      'Accept-Ranges': 'bytes',\n    });\n\n    if (enableCaching) {\n      headers.set('Cache-Control', 'public, max-age=3600'); // 1 hour\n      headers.set('ETag', `\"${fileSize}-${Math.floor(Date.now() / 1000)}\"`);\n    }\n\n    return new NextResponse(readableStream, {\n      status: 200,\n      headers,\n    });\n  }\n\n  /**\n   * Get audio metadata\n   */\n  async getAudioMetadata(filePath: string): Promise<AudioMetadata | null> {\n    try {\n      const fullPath = join(this.uploadPath, filePath);\n      const stats = statSync(fullPath);\n      \n      // This is a simplified metadata extraction\n      // In a real implementation, you'd use a library like node-ffmpeg or music-metadata\n      return {\n        duration: 0, // Would be extracted from file\n        bitrate: 320, // Would be extracted from file\n        sampleRate: 44100, // Would be extracted from file\n        channels: 2, // Would be extracted from file\n        format: this.getFileExtension(filePath),\n        size: stats.size,\n      };\n    } catch (error) {\n      console.error('Error getting audio metadata:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Generate multiple quality versions of an audio file\n   */\n  async generateQualityVersions(\n    originalPath: string,\n    outputDir: string\n  ): Promise<Record<string, string>> {\n    const versions: Record<string, string> = {};\n    \n    // This would use FFmpeg or similar to generate different quality versions\n    // For now, we'll return the original file for all qualities\n    Object.keys(this.qualityPresets).forEach(quality => {\n      versions[quality] = originalPath; // In reality, this would be different files\n    });\n    \n    return versions;\n  }\n\n  /**\n   * Validate audio file format\n   */\n  isValidAudioFile(filename: string): boolean {\n    const extension = this.getFileExtension(filename).toLowerCase();\n    return this.supportedFormats.includes(extension);\n  }\n\n  /**\n   * Get optimal streaming quality based on client capabilities\n   */\n  getOptimalQuality(\n    userAgent: string,\n    connectionType?: string,\n    bandwidth?: number\n  ): keyof typeof this.qualityPresets {\n    // Simple quality selection logic\n    if (connectionType === '4g' && bandwidth && bandwidth > 10) {\n      return 'high';\n    } else if (connectionType === '4g' || (bandwidth && bandwidth > 5)) {\n      return 'medium';\n    } else if (connectionType === '3g' || (bandwidth && bandwidth > 1.5)) {\n      return 'medium';\n    } else {\n      return 'low';\n    }\n  }\n\n  /**\n   * Create streaming playlist (HLS/DASH)\n   */\n  async createStreamingPlaylist(\n    audioFiles: string[],\n    format: 'hls' | 'dash' = 'hls'\n  ): Promise<string> {\n    // This would generate HLS or DASH playlists for adaptive streaming\n    // For now, return a simple playlist\n    const playlist = audioFiles.map((file, index) => {\n      return `#EXTINF:${index + 1},Track ${index + 1}\\n${file}`;\n    }).join('\\n');\n    \n    return `#EXTM3U\\n${playlist}`;\n  }\n\n  /**\n   * Handle audio upload and processing\n   */\n  async processAudioUpload(\n    file: File,\n    options: {\n      generateQualities?: boolean;\n      extractMetadata?: boolean;\n      normalize?: boolean;\n    } = {}\n  ): Promise<{\n    success: boolean;\n    filePath?: string;\n    metadata?: AudioMetadata;\n    qualities?: Record<string, string>;\n    error?: string;\n  }> {\n    try {\n      // Validate file\n      if (!this.isValidAudioFile(file.name)) {\n        return {\n          success: false,\n          error: 'Invalid audio file format',\n        };\n      }\n\n      // Generate unique filename\n      const timestamp = Date.now();\n      const extension = this.getFileExtension(file.name);\n      const filename = `${timestamp}-${Math.random().toString(36).substr(2, 9)}.${extension}`;\n      const filePath = join(this.uploadPath, filename);\n\n      // Save file (this would be implemented based on your file storage solution)\n      // For now, we'll simulate the process\n      \n      const result: any = {\n        success: true,\n        filePath: filename,\n      };\n\n      // Extract metadata if requested\n      if (options.extractMetadata) {\n        result.metadata = await this.getAudioMetadata(filename);\n      }\n\n      // Generate quality versions if requested\n      if (options.generateQualities) {\n        result.qualities = await this.generateQualityVersions(filename, this.uploadPath);\n      }\n\n      return result;\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n\n  /**\n   * Get content type for audio file\n   */\n  private getContentType(filePath: string): string {\n    const extension = this.getFileExtension(filePath).toLowerCase();\n    \n    const mimeTypes: Record<string, string> = {\n      mp3: 'audio/mpeg',\n      aac: 'audio/aac',\n      ogg: 'audio/ogg',\n      webm: 'audio/webm',\n      m4a: 'audio/mp4',\n      wav: 'audio/wav',\n      flac: 'audio/flac',\n    };\n    \n    return mimeTypes[extension] || 'audio/mpeg';\n  }\n\n  /**\n   * Get file extension from filename\n   */\n  private getFileExtension(filename: string): string {\n    return filename.split('.').pop() || '';\n  }\n}\n\n// Export singleton instance\nexport const audioStreamingService = AudioStreamingService.getInstance();\n\n/**\n * Utility functions for audio streaming\n */\nexport const AudioStreamingUtils = {\n  /**\n   * Calculate optimal chunk size based on bitrate\n   */\n  calculateChunkSize(bitrate: number): number {\n    // Calculate chunk size for ~2 seconds of audio\n    return Math.max(64 * 1024, (bitrate * 1000 * 2) / 8); // Convert to bytes\n  },\n\n  /**\n   * Parse range header\n   */\n  parseRangeHeader(rangeHeader: string, fileSize: number): { start: number; end: number } | null {\n    const match = rangeHeader.match(/bytes=(\\d+)-(\\d*)/i);\n    if (!match) return null;\n\n    const start = parseInt(match[1], 10);\n    const end = match[2] ? parseInt(match[2], 10) : fileSize - 1;\n\n    if (start >= fileSize || end >= fileSize || start > end) {\n      return null;\n    }\n\n    return { start, end };\n  },\n\n  /**\n   * Generate ETag for audio file\n   */\n  generateETag(filePath: string, fileSize: number, lastModified: Date): string {\n    const hash = `${filePath}-${fileSize}-${lastModified.getTime()}`;\n    return `\"${Buffer.from(hash).toString('base64')}\"`;\n  },\n\n  /**\n   * Check if client supports range requests\n   */\n  supportsRangeRequests(userAgent: string): boolean {\n    // Most modern browsers support range requests\n    // This is a simplified check\n    return !userAgent.includes('bot') && !userAgent.includes('crawler');\n  },\n};\n\nexport default audioStreamingService;\n"}