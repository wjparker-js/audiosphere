import { QueryClient, DefaultOptions } from '@tanstack/react-query';\n\n// Enhanced error handling for queries\nconst handleQueryError = (error: any) => {\n  // Log errors in development\n  if (process.env.NODE_ENV === 'development') {\n    console.error('Query Error:', error);\n  }\n  \n  // You can add error reporting service here\n  // Example: Sentry.captureException(error);\n};\n\n// Enhanced error handling for mutations\nconst handleMutationError = (error: any) => {\n  // Log errors in development\n  if (process.env.NODE_ENV === 'development') {\n    console.error('Mutation Error:', error);\n  }\n  \n  // You can add error reporting service here\n  // Example: Sentry.captureException(error);\n};\n\n// Default options for React Query\nconst defaultOptions: DefaultOptions = {\n  queries: {\n    // Stale time - how long data is considered fresh\n    staleTime: 5 * 60 * 1000, // 5 minutes\n    \n    // Garbage collection time - how long unused data stays in cache\n    gcTime: 10 * 60 * 1000, // 10 minutes (formerly cacheTime)\n    \n    // Retry configuration\n    retry: (failureCount, error: any) => {\n      // Don't retry on 4xx errors except 408 (timeout) and 429 (rate limit)\n      if (error?.status >= 400 && error?.status < 500 && ![408, 429].includes(error.status)) {\n        return false;\n      }\n      \n      // Don't retry on network errors that are likely permanent\n      if (error?.code === 'NETWORK_ERROR' && failureCount >= 1) {\n        return false;\n      }\n      \n      // Retry up to 3 times for other errors\n      return failureCount < 3;\n    },\n    \n    // Retry delay with exponential backoff\n    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\n    \n    // Don't refetch on window focus by default (can be overridden per query)\n    refetchOnWindowFocus: false,\n    \n    // Refetch on reconnect\n    refetchOnReconnect: true,\n    \n    // Refetch on mount if data is stale\n    refetchOnMount: true,\n    \n    // Error handling\n    throwOnError: false,\n    \n    // Network mode\n    networkMode: 'online',\n  },\n  mutations: {\n    // Retry configuration for mutations\n    retry: (failureCount, error: any) => {\n      // Don't retry mutations on client errors (4xx)\n      if (error?.status >= 400 && error?.status < 500) {\n        return false;\n      }\n      \n      // Don't retry on network errors\n      if (error?.code === 'NETWORK_ERROR') {\n        return false;\n      }\n      \n      // Retry up to 2 times for server errors\n      return failureCount < 2;\n    },\n    \n    // Retry delay for mutations\n    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 10000),\n    \n    // Error handling\n    throwOnError: false,\n    \n    // Network mode\n    networkMode: 'online',\n  },\n};\n\n// Create and configure the query client\nexport const createQueryClient = () => {\n  return new QueryClient({\n    defaultOptions,\n    queryCache: {\n      onError: handleQueryError,\n    },\n    mutationCache: {\n      onError: handleMutationError,\n    },\n  });\n};\n\n// Export a singleton instance for use in the app\nlet queryClient: QueryClient | undefined;\n\nexport const getQueryClient = () => {\n  if (!queryClient) {\n    queryClient = createQueryClient();\n  }\n  return queryClient;\n};\n\n// Query key factory for consistent key generation\nexport const queryKeys = {\n  // Albums\n  albums: ['albums'] as const,\n  album: (id: number) => ['album', id] as const,\n  albumTracks: (id: number) => ['album', id, 'tracks'] as const,\n  \n  // Tracks\n  tracks: ['tracks'] as const,\n  track: (id: number) => ['track', id] as const,\n  trackLikes: (userId: number) => ['track-likes', userId] as const,\n  \n  // Playlists\n  playlists: ['playlists'] as const,\n  playlist: (id: number) => ['playlist', id] as const,\n  playlistTracks: (id: number) => ['playlist', id, 'tracks'] as const,\n  userPlaylists: (userId: number) => ['playlists', 'user', userId] as const,\n  \n  // Blog\n  blogPosts: ['blog-posts'] as const,\n  blogPost: (id: number) => ['blog-post', id] as const,\n  comments: (blogPostId: number) => ['comments', blogPostId] as const,\n  \n  // Search\n  search: (query: string, type?: string) => ['search', query, type] as const,\n  \n  // Dashboard\n  dashboard: ['dashboard'] as const,\n  \n  // User\n  user: (id: number) => ['user', id] as const,\n  userProfile: ['user-profile'] as const,\n  userLikes: ['user-likes'] as const,\n  userHistory: ['user-history'] as const,\n  \n  // Analytics\n  analytics: (type: string, period: string) => ['analytics', type, period] as const,\n};\n\n// Utility functions for cache management\nexport const cacheUtils = {\n  // Invalidate all queries for a specific entity\n  invalidateEntity: (queryClient: QueryClient, entity: string) => {\n    queryClient.invalidateQueries({ queryKey: [entity] });\n  },\n  \n  // Remove all queries for a specific entity\n  removeEntity: (queryClient: QueryClient, entity: string) => {\n    queryClient.removeQueries({ queryKey: [entity] });\n  },\n  \n  // Clear all cache\n  clearAll: (queryClient: QueryClient) => {\n    queryClient.clear();\n  },\n  \n  // Prefetch data\n  prefetch: async (queryClient: QueryClient, queryKey: any[], queryFn: () => Promise<any>) => {\n    await queryClient.prefetchQuery({\n      queryKey,\n      queryFn,\n      staleTime: 5 * 60 * 1000, // 5 minutes\n    });\n  },\n};\n\nexport default getQueryClient;\n"}