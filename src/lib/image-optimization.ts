/**\n * Image optimization utilities for AudioSphere\n * Handles format conversion, compression, and responsive image generation\n */\n\nexport interface ImageOptimizationOptions {\n  quality?: number;\n  format?: 'webp' | 'avif' | 'jpeg' | 'png';\n  width?: number;\n  height?: number;\n  fit?: 'cover' | 'contain' | 'fill' | 'inside' | 'outside';\n  position?: 'center' | 'top' | 'bottom' | 'left' | 'right';\n}\n\nexport interface ResponsiveImageSizes {\n  sm: number;  // 640px\n  md: number;  // 768px\n  lg: number;  // 1024px\n  xl: number;  // 1280px\n  '2xl': number; // 1536px\n}\n\n/**\n * Default responsive breakpoints for images\n */\nexport const DEFAULT_BREAKPOINTS: ResponsiveImageSizes = {\n  sm: 640,\n  md: 768,\n  lg: 1024,\n  xl: 1280,\n  '2xl': 1536,\n};\n\n/**\n * Generate optimized image URL using Next.js Image Optimization API\n */\nexport function getOptimizedImageUrl(\n  src: string,\n  options: ImageOptimizationOptions = {}\n): string {\n  if (!src) return '';\n  \n  // If it's already an optimized URL or external URL, return as is\n  if (src.startsWith('/_next/image') || src.startsWith('http')) {\n    return src;\n  }\n\n  const params = new URLSearchParams();\n  \n  // Add source URL\n  params.set('url', src);\n  \n  // Add optimization parameters\n  if (options.quality) {\n    params.set('q', options.quality.toString());\n  }\n  \n  if (options.width) {\n    params.set('w', options.width.toString());\n  }\n  \n  if (options.height) {\n    params.set('h', options.height.toString());\n  }\n  \n  if (options.format) {\n    params.set('f', options.format);\n  }\n  \n  if (options.fit) {\n    params.set('fit', options.fit);\n  }\n  \n  if (options.position) {\n    params.set('position', options.position);\n  }\n\n  return `/_next/image?${params.toString()}`;\n}\n\n/**\n * Generate responsive image sizes string for Next.js Image component\n */\nexport function generateImageSizes(\n  breakpoints: Partial<ResponsiveImageSizes> = {},\n  defaultSize = '100vw'\n): string {\n  const sizes = { ...DEFAULT_BREAKPOINTS, ...breakpoints };\n  \n  const sizeStrings = Object.entries(sizes)\n    .sort(([, a], [, b]) => a - b) // Sort by breakpoint size\n    .map(([key, value]) => {\n      switch (key) {\n        case 'sm':\n          return `(max-width: ${value}px) ${Math.round(value * 0.9)}px`;\n        case 'md':\n          return `(max-width: ${value}px) ${Math.round(value * 0.8)}px`;\n        case 'lg':\n          return `(max-width: ${value}px) ${Math.round(value * 0.7)}px`;\n        case 'xl':\n          return `(max-width: ${value}px) ${Math.round(value * 0.6)}px`;\n        case '2xl':\n          return `(max-width: ${value}px) ${Math.round(value * 0.5)}px`;\n        default:\n          return `(max-width: ${value}px) ${value}px`;\n      }\n    });\n  \n  sizeStrings.push(defaultSize);\n  \n  return sizeStrings.join(', ');\n}\n\n/**\n * Generate srcSet for responsive images\n */\nexport function generateSrcSet(\n  src: string,\n  widths: number[] = [320, 640, 768, 1024, 1280, 1536],\n  options: Omit<ImageOptimizationOptions, 'width'> = {}\n): string {\n  return widths\n    .map(width => {\n      const optimizedUrl = getOptimizedImageUrl(src, { ...options, width });\n      return `${optimizedUrl} ${width}w`;\n    })\n    .join(', ');\n}\n\n/**\n * Get the best image format based on browser support\n */\nexport function getBestImageFormat(): 'avif' | 'webp' | 'jpeg' {\n  if (typeof window === 'undefined') return 'jpeg';\n  \n  // Check for AVIF support\n  const canvas = document.createElement('canvas');\n  canvas.width = 1;\n  canvas.height = 1;\n  \n  try {\n    // Check AVIF support\n    if (canvas.toDataURL('image/avif').indexOf('data:image/avif') === 0) {\n      return 'avif';\n    }\n    \n    // Check WebP support\n    if (canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0) {\n      return 'webp';\n    }\n  } catch (e) {\n    // Fallback to JPEG if there's an error\n  }\n  \n  return 'jpeg';\n}\n\n/**\n * Generate blur data URL for placeholder\n */\nexport function generateBlurDataURL(\n  width = 10,\n  height = 10,\n  color = '#f3f4f6'\n): string {\n  if (typeof window === 'undefined') {\n    // Server-side fallback\n    return `data:image/svg+xml;base64,${Buffer.from(\n      `<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"100%\" height=\"100%\" fill=\"${color}\"/></svg>`\n    ).toString('base64')}`;\n  }\n  \n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  \n  const ctx = canvas.getContext('2d');\n  if (!ctx) return '';\n  \n  ctx.fillStyle = color;\n  ctx.fillRect(0, 0, width, height);\n  \n  return canvas.toDataURL('image/jpeg', 0.1);\n}\n\n/**\n * Image preloader utility\n */\nexport class ImagePreloader {\n  private cache = new Set<string>();\n  private loading = new Set<string>();\n  \n  /**\n   * Preload a single image\n   */\n  async preload(src: string): Promise<void> {\n    if (this.cache.has(src) || this.loading.has(src)) {\n      return;\n    }\n    \n    this.loading.add(src);\n    \n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      \n      img.onload = () => {\n        this.cache.add(src);\n        this.loading.delete(src);\n        resolve();\n      };\n      \n      img.onerror = () => {\n        this.loading.delete(src);\n        reject(new Error(`Failed to preload image: ${src}`));\n      };\n      \n      img.src = src;\n    });\n  }\n  \n  /**\n   * Preload multiple images\n   */\n  async preloadMultiple(sources: string[]): Promise<void> {\n    const promises = sources.map(src => this.preload(src));\n    await Promise.allSettled(promises);\n  }\n  \n  /**\n   * Check if image is cached\n   */\n  isCached(src: string): boolean {\n    return this.cache.has(src);\n  }\n  \n  /**\n   * Clear cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n  \n  /**\n   * Get cache size\n   */\n  getCacheSize(): number {\n    return this.cache.size;\n  }\n}\n\n// Global image preloader instance\nexport const imagePreloader = new ImagePreloader();\n\n/**\n * Utility to determine if an image should use priority loading\n */\nexport function shouldUsePriorityLoading(\n  index: number,\n  isAboveFold = false,\n  maxPriorityImages = 3\n): boolean {\n  return isAboveFold && index < maxPriorityImages;\n}\n\n/**\n * Get optimal image dimensions based on container size and device pixel ratio\n */\nexport function getOptimalImageDimensions(\n  containerWidth: number,\n  containerHeight: number,\n  devicePixelRatio = 1\n): { width: number; height: number } {\n  const dpr = Math.min(devicePixelRatio, 2); // Cap at 2x for performance\n  \n  return {\n    width: Math.round(containerWidth * dpr),\n    height: Math.round(containerHeight * dpr),\n  };\n}\n\n/**\n * Image optimization configuration for different use cases\n */\nexport const IMAGE_CONFIGS = {\n  albumCover: {\n    quality: 80,\n    format: 'webp' as const,\n    sizes: '(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw',\n  },\n  avatar: {\n    quality: 85,\n    format: 'webp' as const,\n    sizes: '(max-width: 768px) 64px, 80px',\n  },\n  blogFeatured: {\n    quality: 75,\n    format: 'webp' as const,\n    sizes: '(max-width: 768px) 100vw, (max-width: 1200px) 75vw, 50vw',\n  },\n  thumbnail: {\n    quality: 70,\n    format: 'webp' as const,\n    sizes: '(max-width: 768px) 150px, 200px',\n  },\n} as const;\n\nexport default {\n  getOptimizedImageUrl,\n  generateImageSizes,\n  generateSrcSet,\n  getBestImageFormat,\n  generateBlurDataURL,\n  ImagePreloader,\n  imagePreloader,\n  shouldUsePriorityLoading,\n  getOptimalImageDimensions,\n  IMAGE_CONFIGS,\n};\n"}