/**\n * Comprehensive validation schemas and middleware for API endpoints\n */\n\nimport { z } from 'zod';\nimport { NextRequest, NextResponse } from 'next/server';\nimport { ErrorHandler } from './error-handler';\n\n// Common validation schemas\nexport const commonSchemas = {\n  id: z.number().int().positive(),\n  email: z.string().email('Invalid email format'),\n  password: z.string().min(8, 'Password must be at least 8 characters')\n    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]/, \n      'Password must contain uppercase, lowercase, number, and special character'),\n  username: z.string().min(3, 'Username must be at least 3 characters')\n    .max(50, 'Username must be less than 50 characters')\n    .regex(/^[a-zA-Z0-9_-]+$/, 'Username can only contain letters, numbers, underscores, and hyphens'),\n  url: z.string().url('Invalid URL format'),\n  slug: z.string().min(1).max(255).regex(/^[a-z0-9-]+$/, 'Invalid slug format'),\n  positiveInt: z.number().int().positive(),\n  nonNegativeInt: z.number().int().min(0),\n  dateString: z.string().datetime('Invalid date format'),\n  optionalString: z.string().optional(),\n  requiredString: z.string().min(1, 'This field is required'),\n};\n\n// File validation schemas\nexport const fileSchemas = {\n  audioFile: z.object({\n    mimetype: z.enum(['audio/mpeg', 'audio/mp4', 'audio/m4a'], {\n      errorMap: () => ({ message: 'Only MP3 and M4A files are allowed' })\n    }),\n    size: z.number().max(50 * 1024 * 1024, 'File size must be less than 50MB'),\n    originalname: z.string().min(1, 'Filename is required')\n  }),\n  \n  imageFile: z.object({\n    mimetype: z.enum(['image/jpeg', 'image/png', 'image/webp'], {\n      errorMap: () => ({ message: 'Only JPEG, PNG, and WebP images are allowed' })\n    }),\n    size: z.number().max(10 * 1024 * 1024, 'Image size must be less than 10MB'),\n    originalname: z.string().min(1, 'Filename is required')\n  })\n};\n\n// Album validation schemas\nexport const albumSchemas = {\n  create: z.object({\n    title: z.string().min(1, 'Title is required').max(255, 'Title too long'),\n    artist: z.string().min(1, 'Artist is required').max(255, 'Artist name too long'),\n    genre: z.string().optional(),\n    releaseDate: z.string().optional(),\n    description: z.string().max(1000, 'Description too long').optional(),\n  }),\n  \n  update: z.object({\n    title: z.string().min(1).max(255).optional(),\n    artist: z.string().min(1).max(255).optional(),\n    genre: z.string().optional(),\n    releaseDate: z.string().optional(),\n    description: z.string().max(1000).optional(),\n  })\n};\n\n// Track validation schemas\nexport const trackSchemas = {\n  create: z.object({\n    trackTitle: z.string().min(1, 'Track title is required').max(255, 'Title too long'),\n    albumId: z.string().regex(/^\\d+$/, 'Invalid album ID').transform(Number),\n  }),\n  \n  update: z.object({\n    title: z.string().min(1).max(255).optional(),\n    artist: z.string().min(1).max(255).optional(),\n    trackNumber: z.number().int().positive().optional(),\n  })\n};\n\n// Playlist validation schemas\nexport const playlistSchemas = {\n  create: z.object({\n    name: z.string().min(1, 'Playlist name is required').max(100, 'Name too long'),\n    description: z.string().max(500, 'Description too long').optional().default(''),\n    isPublic: z.boolean().optional().default(false),\n    userId: z.number().int().positive().optional().default(1)\n  }),\n  \n  update: z.object({\n    name: z.string().min(1).max(100).optional(),\n    description: z.string().max(500).optional(),\n    isPublic: z.boolean().optional(),\n  }),\n  \n  addTrack: z.object({\n    trackId: z.number().int().positive(),\n    position: z.number().int().min(0).optional()\n  })\n};\n\n// Blog validation schemas\nexport const blogSchemas = {\n  create: z.object({\n    title: z.string().min(1, 'Title is required').max(255, 'Title too long'),\n    content: z.string().min(1, 'Content is required'),\n    excerpt: z.string().max(500, 'Excerpt too long').optional(),\n    featuredImage: z.string().url('Invalid image URL').optional(),\n    status: z.enum(['draft', 'published']).optional().default('draft'),\n    userId: z.number().int().positive().optional().default(1)\n  }),\n  \n  update: z.object({\n    title: z.string().min(1).max(255).optional(),\n    content: z.string().min(1).optional(),\n    excerpt: z.string().max(500).optional(),\n    featuredImage: z.string().url().optional(),\n    status: z.enum(['draft', 'published']).optional(),\n  })\n};\n\n// User validation schemas\nexport const userSchemas = {\n  register: z.object({\n    email: commonSchemas.email,\n    username: commonSchemas.username,\n    password: commonSchemas.password,\n    confirmPassword: z.string()\n  }).refine((data) => data.password === data.confirmPassword, {\n    message: \"Passwords don't match\",\n    path: [\"confirmPassword\"],\n  }),\n  \n  login: z.object({\n    email: commonSchemas.email,\n    password: z.string().min(1, 'Password is required')\n  }),\n  \n  updateProfile: z.object({\n    username: commonSchemas.username.optional(),\n    bio: z.string().max(500, 'Bio too long').optional(),\n    location: z.string().max(100, 'Location too long').optional(),\n    website: z.string().url('Invalid website URL').optional(),\n    avatar: z.string().url('Invalid avatar URL').optional()\n  })\n};\n\n// Search validation schemas\nexport const searchSchemas = {\n  query: z.object({\n    q: z.string().min(1, 'Search query is required').max(100, 'Query too long'),\n    types: z.string().optional().default('albums,tracks,playlists,blogs'),\n    limit: z.string().regex(/^\\d+$/).transform(Number).pipe(z.number().int().min(1).max(100)).optional().default(20),\n    userId: z.string().regex(/^\\d+$/).transform(Number).optional().default(1)\n  })\n};\n\n// Dashboard validation schemas\nexport const dashboardSchemas = {\n  query: z.object({\n    albumLimit: z.string().regex(/^\\d+$/).transform(Number).pipe(z.number().int().min(0).max(100)).optional().default(20),\n    playlistLimit: z.string().regex(/^\\d+$/).transform(Number).pipe(z.number().int().min(0).max(100)).optional().default(20),\n    trackLimit: z.string().regex(/^\\d+$/).transform(Number).pipe(z.number().int().min(0).max(100)).optional().default(10),\n    blogLimit: z.string().regex(/^\\d+$/).transform(Number).pipe(z.number().int().min(0).max(100)).optional().default(10),\n    userId: z.string().regex(/^\\d+$/).transform(Number).optional().default(1)\n  })\n};\n\n// Validation middleware factory\nexport function createValidationMiddleware<T>(schema: z.ZodSchema<T>) {\n  return async (request: NextRequest, validationType: 'body' | 'query' | 'params' = 'body') => {\n    try {\n      let data: any;\n      \n      switch (validationType) {\n        case 'body':\n          data = await request.json();\n          break;\n        case 'query':\n          data = Object.fromEntries(new URL(request.url).searchParams.entries());\n          break;\n        case 'params':\n          // This would be handled by the route handler\n          throw new Error('Params validation should be handled in route handler');\n        default:\n          throw new Error('Invalid validation type');\n      }\n      \n      const validatedData = schema.parse(data);\n      return { success: true, data: validatedData };\n      \n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        const validationErrors = error.errors.map(err => ({\n          field: err.path.join('.'),\n          message: err.message,\n          code: err.code.toUpperCase()\n        }));\n        \n        return {\n          success: false,\n          error: ErrorHandler.handleValidationError({\n            name: 'ValidationError',\n            message: 'Invalid input data provided',\n            details: validationErrors\n          } as any)\n        };\n      }\n      \n      return {\n        success: false,\n        error: ErrorHandler.handleGenericError(error as Error)\n      };\n    }\n  };\n}\n\n// Validation wrapper for API handlers\nexport function withValidation<T>(\n  schema: z.ZodSchema<T>,\n  handler: (request: NextRequest, validatedData: T, ...args: any[]) => Promise<NextResponse>,\n  validationType: 'body' | 'query' = 'body'\n) {\n  return async (request: NextRequest, ...args: any[]): Promise<NextResponse> => {\n    const validator = createValidationMiddleware(schema);\n    const result = await validator(request, validationType);\n    \n    if (!result.success) {\n      return result.error;\n    }\n    \n    return handler(request, result.data, ...args);\n  };\n}\n\n// File validation helper\nexport async function validateFile(file: File, type: 'audio' | 'image'): Promise<{ success: boolean; error?: NextResponse }> {\n  try {\n    const fileData = {\n      mimetype: file.type,\n      size: file.size,\n      originalname: file.name\n    };\n    \n    const schema = type === 'audio' ? fileSchemas.audioFile : fileSchemas.imageFile;\n    schema.parse(fileData);\n    \n    return { success: true };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      const validationErrors = error.errors.map(err => ({\n        field: err.path.join('.'),\n        message: err.message,\n        code: err.code.toUpperCase()\n      }));\n      \n      return {\n        success: false,\n        error: ErrorHandler.handleValidationError({\n          name: 'ValidationError',\n          message: 'Invalid file provided',\n          details: validationErrors\n        } as any)\n      };\n    }\n    \n    return {\n      success: false,\n      error: ErrorHandler.handleGenericError(error as Error)\n    };\n  }\n}\n\n// Rate limiting validation\nexport const rateLimitSchemas = {\n  auth: {\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    max: 5, // 5 attempts per window\n    message: 'Too many authentication attempts. Please try again later.'\n  },\n  \n  api: {\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    max: 100, // 100 requests per window\n    message: 'Too many requests. Please try again later.'\n  },\n  \n  upload: {\n    windowMs: 60 * 60 * 1000, // 1 hour\n    max: 10, // 10 uploads per hour\n    message: 'Too many file uploads. Please try again later.'\n  }\n};\n"