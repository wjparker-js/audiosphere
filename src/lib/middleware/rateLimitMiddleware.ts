import { NextRequest, NextResponse } from 'next/server';\nimport { withRateLimit, rateLimitConfigs } from '@/lib/rate-limiting';\n\n/**\n * Higher-order function that applies rate limiting to API route handlers\n */\nexport function withRateLimitMiddleware(\n  handler: (req: NextRequest, context?: any) => Promise<NextResponse>,\n  limitType: keyof typeof rateLimitConfigs = 'api'\n) {\n  const rateLimitCheck = withRateLimit(limitType);\n  \n  return async function rateLimitedHandler(req: NextRequest, context?: any): Promise<NextResponse> {\n    try {\n      // Check rate limit\n      const rateLimitResponse = await rateLimitCheck(req);\n      \n      if (rateLimitResponse) {\n        // Rate limit exceeded, return the rate limit response\n        return rateLimitResponse;\n      }\n      \n      // Rate limit passed, call the original handler\n      return await handler(req, context);\n    } catch (error) {\n      console.error('Rate limit middleware error:', error);\n      \n      // On error, return a 500 response\n      return NextResponse.json(\n        {\n          success: false,\n          error: {\n            code: 'INTERNAL_SERVER_ERROR',\n            message: 'An internal server error occurred',\n          },\n        },\n        { status: 500 }\n      );\n    }\n  };\n}\n\n/**\n * Middleware specifically for authentication endpoints\n */\nexport function withAuthRateLimit(\n  handler: (req: NextRequest, context?: any) => Promise<NextResponse>\n) {\n  return withRateLimitMiddleware(handler, 'auth');\n}\n\n/**\n * Middleware specifically for file upload endpoints\n */\nexport function withUploadRateLimit(\n  handler: (req: NextRequest, context?: any) => Promise<NextResponse>\n) {\n  return withRateLimitMiddleware(handler, 'upload');\n}\n\n/**\n * Middleware specifically for search endpoints\n */\nexport function withSearchRateLimit(\n  handler: (req: NextRequest, context?: any) => Promise<NextResponse>\n) {\n  return withRateLimitMiddleware(handler, 'search');\n}\n\n/**\n * Middleware specifically for password reset endpoints\n */\nexport function withPasswordResetRateLimit(\n  handler: (req: NextRequest, context?: any) => Promise<NextResponse>\n) {\n  return withRateLimitMiddleware(handler, 'passwordReset');\n}\n\n/**\n * Middleware specifically for posting endpoints (comments, blog posts)\n */\nexport function withPostingRateLimit(\n  handler: (req: NextRequest, context?: any) => Promise<NextResponse>\n) {\n  return withRateLimitMiddleware(handler, 'posting');\n}\n\n/**\n * Custom rate limit middleware with advanced options\n */\nexport function withCustomRateLimit(\n  handler: (req: NextRequest, context?: any) => Promise<NextResponse>,\n  options: {\n    windowMs: number;\n    max: number;\n    message?: string;\n    skipIf?: (req: NextRequest) => boolean;\n  }\n) {\n  const customConfig = {\n    windowMs: options.windowMs,\n    max: options.max,\n    message: {\n      success: false,\n      error: {\n        code: 'CUSTOM_RATE_LIMIT_EXCEEDED',\n        message: options.message || 'Rate limit exceeded. Please try again later.',\n        retryAfter: Math.ceil(options.windowMs / 1000),\n      },\n    },\n    standardHeaders: true,\n    legacyHeaders: false,\n  };\n  \n  return async function customRateLimitedHandler(req: NextRequest, context?: any): Promise<NextResponse> {\n    try {\n      // Check skip condition\n      if (options.skipIf && options.skipIf(req)) {\n        return await handler(req, context);\n      }\n      \n      // Apply custom rate limiting logic here\n      // For now, we'll use the standard rate limiting\n      const rateLimitCheck = withRateLimit('api'); // This would need to be customized\n      const rateLimitResponse = await rateLimitCheck(req);\n      \n      if (rateLimitResponse) {\n        return rateLimitResponse;\n      }\n      \n      return await handler(req, context);\n    } catch (error) {\n      console.error('Custom rate limit middleware error:', error);\n      \n      return NextResponse.json(\n        {\n          success: false,\n          error: {\n            code: 'INTERNAL_SERVER_ERROR',\n            message: 'An internal server error occurred',\n          },\n        },\n        { status: 500 }\n      );\n    }\n  };\n}\n\n/**\n * Utility function to combine multiple middlewares\n */\nexport function combineMiddlewares(\n  ...middlewares: Array<(handler: any) => any>\n) {\n  return function combinedMiddleware(handler: any) {\n    return middlewares.reduceRight((acc, middleware) => middleware(acc), handler);\n  };\n}\n\n/**\n * Example usage:\n * \n * // Basic API rate limiting\n * export const GET = withRateLimitMiddleware(async (req) => {\n *   // Your handler logic here\n *   return NextResponse.json({ success: true });\n * });\n * \n * // Authentication rate limiting\n * export const POST = withAuthRateLimit(async (req) => {\n *   // Your login logic here\n *   return NextResponse.json({ success: true });\n * });\n * \n * // Custom rate limiting\n * export const POST = withCustomRateLimit(async (req) => {\n *   // Your handler logic here\n *   return NextResponse.json({ success: true });\n * }, {\n *   windowMs: 60 * 1000, // 1 minute\n *   max: 5, // 5 requests per minute\n *   message: 'Too many requests to this endpoint',\n *   skipIf: (req) => req.headers.get('authorization')?.includes('admin')\n * });\n * \n * // Combining multiple middlewares\n * export const POST = combineMiddlewares(\n *   withAuthRateLimit,\n *   withErrorHandling,\n *   withValidation(loginSchema)\n * )(async (req) => {\n *   // Your handler logic here\n *   return NextResponse.json({ success: true });\n * });\n */\n\nexport default {\n  withRateLimitMiddleware,\n  withAuthRateLimit,\n  withUploadRateLimit,\n  withSearchRateLimit,\n  withPasswordResetRateLimit,\n  withPostingRateLimit,\n  withCustomRateLimit,\n  combineMiddlewares,\n};\n"}