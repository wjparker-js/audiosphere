/**\n * Client-side image compression utilities\n * Handles image resizing, format conversion, and quality optimization\n */\n\nexport interface CompressionOptions {\n  maxWidth?: number;\n  maxHeight?: number;\n  quality?: number;\n  format?: 'jpeg' | 'png' | 'webp';\n  maintainAspectRatio?: boolean;\n}\n\nexport interface CompressionResult {\n  file: File;\n  originalSize: number;\n  compressedSize: number;\n  compressionRatio: number;\n  dimensions: {\n    width: number;\n    height: number;\n  };\n}\n\n/**\n * Compress an image file on the client side\n */\nexport async function compressImage(\n  file: File,\n  options: CompressionOptions = {}\n): Promise<CompressionResult> {\n  const {\n    maxWidth = 1920,\n    maxHeight = 1080,\n    quality = 0.8,\n    format = 'jpeg',\n    maintainAspectRatio = true,\n  } = options;\n\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n\n    if (!ctx) {\n      reject(new Error('Canvas context not available'));\n      return;\n    }\n\n    img.onload = () => {\n      // Calculate new dimensions\n      let { width, height } = calculateDimensions(\n        img.width,\n        img.height,\n        maxWidth,\n        maxHeight,\n        maintainAspectRatio\n      );\n\n      // Set canvas dimensions\n      canvas.width = width;\n      canvas.height = height;\n\n      // Draw and compress image\n      ctx.drawImage(img, 0, 0, width, height);\n\n      // Convert to blob\n      canvas.toBlob(\n        (blob) => {\n          if (!blob) {\n            reject(new Error('Failed to compress image'));\n            return;\n          }\n\n          // Create new file\n          const compressedFile = new File(\n            [blob],\n            `${file.name.split('.')[0]}.${format === 'jpeg' ? 'jpg' : format}`,\n            {\n              type: `image/${format}`,\n              lastModified: Date.now(),\n            }\n          );\n\n          const result: CompressionResult = {\n            file: compressedFile,\n            originalSize: file.size,\n            compressedSize: blob.size,\n            compressionRatio: (1 - blob.size / file.size) * 100,\n            dimensions: { width, height },\n          };\n\n          resolve(result);\n        },\n        `image/${format}`,\n        quality\n      );\n    };\n\n    img.onerror = () => {\n      reject(new Error('Failed to load image'));\n    };\n\n    // Load image\n    img.src = URL.createObjectURL(file);\n  });\n}\n\n/**\n * Calculate optimal dimensions while maintaining aspect ratio\n */\nfunction calculateDimensions(\n  originalWidth: number,\n  originalHeight: number,\n  maxWidth: number,\n  maxHeight: number,\n  maintainAspectRatio: boolean\n): { width: number; height: number } {\n  if (!maintainAspectRatio) {\n    return {\n      width: Math.min(originalWidth, maxWidth),\n      height: Math.min(originalHeight, maxHeight),\n    };\n  }\n\n  const aspectRatio = originalWidth / originalHeight;\n\n  let width = originalWidth;\n  let height = originalHeight;\n\n  // Scale down if necessary\n  if (width > maxWidth) {\n    width = maxWidth;\n    height = width / aspectRatio;\n  }\n\n  if (height > maxHeight) {\n    height = maxHeight;\n    width = height * aspectRatio;\n  }\n\n  return {\n    width: Math.round(width),\n    height: Math.round(height),\n  };\n}\n\n/**\n * Batch compress multiple images\n */\nexport async function compressImages(\n  files: File[],\n  options: CompressionOptions = {}\n): Promise<CompressionResult[]> {\n  const results: CompressionResult[] = [];\n  \n  for (const file of files) {\n    try {\n      const result = await compressImage(file, options);\n      results.push(result);\n    } catch (error) {\n      console.error(`Failed to compress ${file.name}:`, error);\n      // Continue with other files\n    }\n  }\n  \n  return results;\n}\n\n/**\n * Get image metadata without loading the full image\n */\nexport function getImageMetadata(file: File): Promise<{\n  width: number;\n  height: number;\n  size: number;\n  type: string;\n  name: string;\n}> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    \n    img.onload = () => {\n      resolve({\n        width: img.width,\n        height: img.height,\n        size: file.size,\n        type: file.type,\n        name: file.name,\n      });\n      \n      // Clean up\n      URL.revokeObjectURL(img.src);\n    };\n    \n    img.onerror = () => {\n      reject(new Error('Failed to load image metadata'));\n    };\n    \n    img.src = URL.createObjectURL(file);\n  });\n}\n\n/**\n * Convert image to different format\n */\nexport async function convertImageFormat(\n  file: File,\n  targetFormat: 'jpeg' | 'png' | 'webp',\n  quality = 0.8\n): Promise<File> {\n  const result = await compressImage(file, {\n    format: targetFormat,\n    quality,\n    maxWidth: 4096, // Don't resize, just convert\n    maxHeight: 4096,\n  });\n  \n  return result.file;\n}\n\n/**\n * Create image thumbnail\n */\nexport async function createThumbnail(\n  file: File,\n  size = 150,\n  quality = 0.7\n): Promise<File> {\n  const result = await compressImage(file, {\n    maxWidth: size,\n    maxHeight: size,\n    quality,\n    format: 'jpeg',\n  });\n  \n  return result.file;\n}\n\n/**\n * Validate image file\n */\nexport function validateImageFile(\n  file: File,\n  options: {\n    maxSize?: number;\n    allowedTypes?: string[];\n    minWidth?: number;\n    minHeight?: number;\n    maxWidth?: number;\n    maxHeight?: number;\n  } = {}\n): Promise<{\n  isValid: boolean;\n  errors: string[];\n  metadata?: {\n    width: number;\n    height: number;\n    size: number;\n    type: string;\n  };\n}> {\n  const {\n    maxSize = 10 * 1024 * 1024, // 10MB\n    allowedTypes = ['image/jpeg', 'image/png', 'image/webp'],\n    minWidth = 1,\n    minHeight = 1,\n    maxWidth = 4096,\n    maxHeight = 4096,\n  } = options;\n\n  return new Promise((resolve) => {\n    const errors: string[] = [];\n\n    // Check file type\n    if (!allowedTypes.includes(file.type)) {\n      errors.push(`Invalid file type. Allowed types: ${allowedTypes.join(', ')}`);\n    }\n\n    // Check file size\n    if (file.size > maxSize) {\n      errors.push(`File size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds maximum allowed size (${(maxSize / 1024 / 1024).toFixed(2)}MB)`);\n    }\n\n    // If basic validation fails, return early\n    if (errors.length > 0) {\n      resolve({ isValid: false, errors });\n      return;\n    }\n\n    // Check image dimensions\n    getImageMetadata(file)\n      .then((metadata) => {\n        if (metadata.width < minWidth || metadata.height < minHeight) {\n          errors.push(`Image dimensions (${metadata.width}x${metadata.height}) are too small. Minimum: ${minWidth}x${minHeight}`);\n        }\n\n        if (metadata.width > maxWidth || metadata.height > maxHeight) {\n          errors.push(`Image dimensions (${metadata.width}x${metadata.height}) are too large. Maximum: ${maxWidth}x${maxHeight}`);\n        }\n\n        resolve({\n          isValid: errors.length === 0,\n          errors,\n          metadata,\n        });\n      })\n      .catch(() => {\n        errors.push('Failed to read image metadata');\n        resolve({ isValid: false, errors });\n      });\n  });\n}\n\n/**\n * Compression presets for different use cases\n */\nexport const COMPRESSION_PRESETS = {\n  avatar: {\n    maxWidth: 200,\n    maxHeight: 200,\n    quality: 0.85,\n    format: 'jpeg' as const,\n  },\n  albumCover: {\n    maxWidth: 800,\n    maxHeight: 800,\n    quality: 0.8,\n    format: 'jpeg' as const,\n  },\n  blogImage: {\n    maxWidth: 1200,\n    maxHeight: 800,\n    quality: 0.75,\n    format: 'jpeg' as const,\n  },\n  thumbnail: {\n    maxWidth: 150,\n    maxHeight: 150,\n    quality: 0.7,\n    format: 'jpeg' as const,\n  },\n  highQuality: {\n    maxWidth: 1920,\n    maxHeight: 1080,\n    quality: 0.9,\n    format: 'jpeg' as const,\n  },\n} as const;\n\nexport default {\n  compressImage,\n  compressImages,\n  getImageMetadata,\n  convertImageFormat,\n  createThumbnail,\n  validateImageFile,\n  COMPRESSION_PRESETS,\n};\n"}