# Rate Limiting Implementation\n\nThis document describes the comprehensive rate limiting system implemented in AudioSphere to protect against abuse and ensure fair usage of API resources.\n\n## Overview\n\nThe rate limiting system provides multiple layers of protection:\n\n1. **Express Rate Limit Integration**: Uses the popular `express-rate-limit` package\n2. **Endpoint-Specific Limits**: Different limits for different types of endpoints\n3. **Advanced Custom Limiters**: Custom implementation for complex scenarios\n4. **Middleware Integration**: Easy-to-use middleware for Next.js API routes\n5. **Error Handling**: Consistent error responses when limits are exceeded\n\n## Rate Limit Configurations\n\n### Authentication Endpoints\n- **Window**: 15 minutes\n- **Limit**: 5 attempts\n- **Purpose**: Prevent brute force attacks\n- **Behavior**: Doesn't count successful requests\n\n### File Upload Endpoints\n- **Window**: 1 minute\n- **Limit**: 10 uploads\n- **Purpose**: Prevent resource exhaustion\n- **Use Cases**: Audio file uploads, image uploads\n\n### General API Endpoints\n- **Window**: 15 minutes\n- **Limit**: 100 requests\n- **Purpose**: General API protection\n- **Use Cases**: Most CRUD operations\n\n### Search Endpoints\n- **Window**: 1 minute\n- **Limit**: 30 searches\n- **Purpose**: Prevent search abuse\n- **Use Cases**: Music search, blog search\n\n### Password Reset Endpoints\n- **Window**: 1 hour\n- **Limit**: 3 attempts\n- **Purpose**: Prevent password reset abuse\n- **Behavior**: Very strict limits\n\n### Posting Endpoints\n- **Window**: 5 minutes\n- **Limit**: 20 posts\n- **Purpose**: Prevent spam\n- **Use Cases**: Comments, blog posts\n\n## Usage Examples\n\n### Basic Rate Limiting\n\n```typescript\nimport { withRateLimitMiddleware } from '@/lib/middleware/rateLimitMiddleware';\n\nexport const GET = withRateLimitMiddleware(\n  async (req: NextRequest) => {\n    // Your handler logic here\n    return NextResponse.json({ success: true });\n  },\n  'api' // Use API rate limiting\n);\n```\n\n### Authentication Rate Limiting\n\n```typescript\nimport { withAuthRateLimit } from '@/lib/middleware/rateLimitMiddleware';\n\nexport const POST = withAuthRateLimit(\n  async (req: NextRequest) => {\n    // Login logic here\n    return NextResponse.json({ success: true });\n  }\n);\n```\n\n### Custom Rate Limiting\n\n```typescript\nimport { withCustomRateLimit } from '@/lib/middleware/rateLimitMiddleware';\n\nexport const POST = withCustomRateLimit(\n  async (req: NextRequest) => {\n    // Your handler logic here\n    return NextResponse.json({ success: true });\n  },\n  {\n    windowMs: 60 * 1000, // 1 minute\n    max: 5, // 5 requests per minute\n    message: 'Too many requests to this endpoint',\n    skipIf: (req) => req.headers.get('authorization')?.includes('admin')\n  }\n);\n```\n\n### Combining Multiple Middlewares\n\n```typescript\nimport { \n  combineMiddlewares, \n  withAuthRateLimit \n} from '@/lib/middleware/rateLimitMiddleware';\nimport { withErrorHandling } from '@/lib/error-handler';\nimport { withValidation } from '@/lib/validation';\n\nexport const POST = combineMiddlewares(\n  withAuthRateLimit,\n  withErrorHandling,\n  (handler) => withValidation(loginSchema, handler)\n)(async (req: NextRequest) => {\n  // Your handler logic here\n  return NextResponse.json({ success: true });\n});\n```\n\n## Advanced Rate Limiting\n\n### Custom Rate Limiter Class\n\nFor complex scenarios, use the `AdvancedRateLimiter` class:\n\n```typescript\nimport { AdvancedRateLimiter } from '@/lib/rate-limiting';\n\nconst customLimiter = new AdvancedRateLimiter({\n  windowMs: 60 * 1000, // 1 minute\n  max: 10,\n  keyGenerator: (req) => `custom:${req.ip}:${req.headers.get('user-id')}`,\n  skipIf: (req) => req.headers.get('x-admin') === 'true',\n  onLimitReached: (req, key) => {\n    console.warn(`Rate limit exceeded for ${key}`);\n    // Additional security measures\n  }\n});\n\nexport const POST = async (req: NextRequest) => {\n  const { allowed, remaining, resetTime } = await customLimiter.check(req);\n  \n  if (!allowed) {\n    return NextResponse.json(\n      {\n        success: false,\n        error: {\n          code: 'RATE_LIMIT_EXCEEDED',\n          message: 'Rate limit exceeded',\n          retryAfter: Math.ceil((resetTime - Date.now()) / 1000)\n        }\n      },\n      { \n        status: 429,\n        headers: {\n          'X-RateLimit-Remaining': remaining.toString(),\n          'X-RateLimit-Reset': new Date(resetTime).toISOString()\n        }\n      }\n    );\n  }\n  \n  // Process request\n  return NextResponse.json({ success: true });\n};\n```\n\n## Error Responses\n\nWhen rate limits are exceeded, the system returns consistent error responses:\n\n```json\n{\n  \"success\": false,\n  \"error\": {\n    \"code\": \"RATE_LIMIT_EXCEEDED\",\n    \"message\": \"Too many requests. Please try again later.\",\n    \"retryAfter\": 900\n  }\n}\n```\n\n### Response Headers\n\nRate limiting responses include standard headers:\n\n- `X-RateLimit-Limit`: The rate limit ceiling for that given request\n- `X-RateLimit-Remaining`: The number of requests left for the time window\n- `X-RateLimit-Reset`: The time at which the rate limit window resets\n- `Retry-After`: The number of seconds to wait before retrying\n\n## Security Features\n\n### IP-Based Limiting\n\nBy default, rate limiting is applied per IP address. The system intelligently extracts the client IP from:\n\n1. `x-forwarded-for` header (for proxied requests)\n2. `x-real-ip` header (for reverse proxies)\n3. Direct connection IP\n4. Fallback to `127.0.0.1`\n\n### Skip Conditions\n\nRate limiting can be bypassed based on conditions:\n\n```typescript\nskipIf: (req) => {\n  // Skip for admin users\n  const isAdmin = checkAdminStatus(req);\n  return isAdmin;\n}\n```\n\n### Automatic Cleanup\n\nThe advanced rate limiter automatically cleans up expired entries to prevent memory leaks.\n\n## Monitoring and Logging\n\n### Rate Limit Events\n\nThe system logs important events:\n\n```typescript\n// When limits are reached\nconsole.warn(`Rate limit exceeded for ${clientIP}`);\n\n// Custom monitoring\nonLimitReached: (req, key) => {\n  // Send to monitoring service\n  monitoringService.recordRateLimitExceeded(key);\n  \n  // Implement additional security measures\n  if (isRepeatedOffender(key)) {\n    temporarilyBlockIP(key);\n  }\n}\n```\n\n### Metrics Collection\n\nImplement metrics collection for monitoring:\n\n```typescript\n// Track rate limit hits\nmetrics.increment('rate_limit.hit', {\n  endpoint: req.url,\n  limit_type: 'auth'\n});\n\n// Track successful requests\nmetrics.increment('rate_limit.allowed', {\n  endpoint: req.url,\n  limit_type: 'auth'\n});\n```\n\n## Best Practices\n\n### 1. Choose Appropriate Limits\n\n- **Authentication**: Very strict (5 per 15 minutes)\n- **File Uploads**: Moderate (10 per minute)\n- **Search**: Generous but controlled (30 per minute)\n- **General API**: Liberal (100 per 15 minutes)\n\n### 2. Provide Clear Error Messages\n\n```typescript\nmessage: {\n  success: false,\n  error: {\n    code: 'RATE_LIMIT_EXCEEDED',\n    message: 'Too many login attempts. Please try again in 15 minutes.',\n    retryAfter: 900\n  }\n}\n```\n\n### 3. Implement Graceful Degradation\n\n```typescript\n// Fail open on rate limiter errors\ntry {\n  const rateLimitResponse = await limiter(req);\n  if (rateLimitResponse) return rateLimitResponse;\n} catch (error) {\n  console.error('Rate limiting error:', error);\n  // Allow request to continue\n}\n```\n\n### 4. Use Different Keys for Different Contexts\n\n```typescript\n// User-specific limiting\nkeyGenerator: (req) => `user:${getUserId(req)}`\n\n// IP + endpoint specific\nkeyGenerator: (req) => `${req.ip}:${req.url}`\n\n// Combined approach\nkeyGenerator: (req) => `${req.ip}:${getUserId(req)}:${getEndpointType(req)}`\n```\n\n## Testing Rate Limits\n\nUse the demo endpoint to test rate limiting:\n\n```bash\n# Test basic API rate limiting\ncurl -X GET http://localhost:3000/api/examples/rate-limit-demo\n\n# Test custom rate limiting\ncurl -X POST http://localhost:3000/api/examples/rate-limit-demo \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"test\": true}'\n\n# Test admin bypass\ncurl -X POST http://localhost:3000/api/examples/rate-limit-demo \\\n  -H \"Content-Type: application/json\" \\\n  -H \"x-admin-key: demo-admin-key\" \\\n  -d '{\"test\": true}'\n\n# Test strict limiting\ncurl -X DELETE http://localhost:3000/api/examples/rate-limit-demo\n```\n\n## Configuration\n\nRate limiting configurations are centralized in `/src/lib/rate-limiting.ts` and can be easily modified:\n\n```typescript\nexport const rateLimitConfigs = {\n  auth: {\n    windowMs: 15 * 60 * 1000, // Adjust window\n    max: 5, // Adjust limit\n    // ... other options\n  },\n  // ... other configurations\n};\n```\n\n## Deployment Considerations\n\n### Production Environment\n\n1. **Redis Integration**: For distributed systems, consider using Redis as the store\n2. **Load Balancer**: Ensure rate limiting works correctly behind load balancers\n3. **Monitoring**: Set up alerts for rate limit violations\n4. **Scaling**: Consider rate limiting at the infrastructure level (CDN, API Gateway)\n\n### Development Environment\n\n1. **Relaxed Limits**: Use higher limits for development\n2. **Easy Bypass**: Implement easy bypass mechanisms for testing\n3. **Clear Logging**: Enable detailed logging for debugging\n\nThis rate limiting system provides comprehensive protection while maintaining flexibility and ease of use.\n"}